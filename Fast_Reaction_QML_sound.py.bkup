import csv
from datetime import datetime
from re import T
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from requests.exceptions import ConnectionError, Timeout, RequestException
import time   
import numpy as np
import json
from PyQt5.QtGui import QPainter, QColor, QFont,QFontDatabase ,QImage, QPixmap,QPen, QPainterPath , QPolygonF, QBrush, QRadialGradient, QLinearGradient, QSurfaceFormat
from PyQt5.QtCore import QTimer,Qt, pyqtSignal, pyqtSlot ,QThread , QTime,QSize,QRectF,QPointF, QUrl, QObject
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget ,QGridLayout,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QTableWidget,QTableWidgetItem,QHeaderView,QFrame
from PyQt5.QtQuickWidgets import QQuickWidget
from PyQt5.QtQml import qmlRegisterType
import math 
import requests , os ,time

from PyQt5 import QtCore, QtGui, QtWidgets
import paho.mqtt.client as mqtt
# from PyQt5.QtMultimedia import QMediaPlayer, QMediaContent

# import New Sound Service
from utils.audio_service import AudioPlayer
from utils.audio_service import AudioService
from utils.audio_service import AudioServiceThread



import sys

# Import our new API and configuration system
from api.game_api import GameAPI
from config import config
from utils.logger import get_logger

# Setup logging
logger = get_logger(__name__)

# Load configuration
game_config = config.settings.game
ui_config = config.settings.ui


class CircularTimerBackend(QObject):
    """
    Backend class that manages countdown timer functionality for the circular timer.

    Signals:
    - timerValueChanged: Emits current timer value and progress percentage
    - countdownStarted: Emits when countdown starts
    - countdownStopped: Emits when countdown stops or finishes
    """

    # Signal to send timer value (seconds remaining, progress percentage 0-100)
    timerValueChanged = pyqtSignal(int, float, arguments=['seconds', 'progress'])

    # Signal to notify countdown started
    countdownStarted = pyqtSignal()

    # Signal to notify countdown stopped
    countdownStopped = pyqtSignal()

    def __init__(self):
        super().__init__()

        # Countdown timer properties
        self.total_seconds = 60  # Default countdown time
        self.remaining_seconds = self.total_seconds
        self.is_running = False

    @pyqtSlot(int)
    def set_timer(self, seconds):
        """Set the countdown timer duration in seconds."""
        if not self.is_running:
            self.total_seconds = seconds
            self.remaining_seconds = seconds
            self.emit_timer_value()

    @pyqtSlot()
    def start_countdown(self):
        """Start the countdown timer."""
        if not self.is_running:
            self.is_running = True
            self.countdownStarted.emit()

    @pyqtSlot()
    def stop_countdown(self):
        """Stop the countdown timer."""
        if self.is_running:
            self.is_running = False
            self.countdownStopped.emit()

    @pyqtSlot()
    def reset_countdown(self):
        """Reset the countdown to initial value."""
        self.stop_countdown()
        self.remaining_seconds = self.total_seconds
        self.emit_timer_value()

    def update_countdown_value(self, remaining_seconds):
        """Update countdown timer value from external source (game timer)."""
        self.remaining_seconds = remaining_seconds
        self.emit_timer_value()

    def emit_timer_value(self):
        """Emit current timer value and progress."""
        if self.total_seconds > 0:
            progress = ((self.total_seconds - self.remaining_seconds) / self.total_seconds) * 100
        else:
            progress = 0
        self.timerValueChanged.emit(self.remaining_seconds, progress)

# Initialize global variables
final_screen_timer_idle = game_config.final_screen_timer
count = 0
TimerValue = game_config.timer_value
global scaled
scaled = 1
scored = 0
serial_scoring_active = False
list_players_name = []
list_players_score = [0,0,0,0,0]
list_players_id = []
list_top5_FastReaction = []
RemainingTime = 0
teamName = ""
homeOpened = False

import numpy as np
gamefinished = False
gameStarted = False
firstDetected = False

response = None


class SimpleSerialThread(QThread):
    """
    Enhanced Serial Thread for Fast Reaction Game
    Reads simple data lines from serial port with automatic reconnection
    """
    # Qt signals for thread communication
    data_received = pyqtSignal(str)  # Emitted when data is received
    connection_status_changed = pyqtSignal(bool)  # Emitted when connection status changes
    error_occurred = pyqtSignal(str)  # Emitted when an error occurs
    
    def __init__(self, config):
        super().__init__()
        self.config = config
        self.port = config.port
        self.baudrate = config.baudrate
        self.timeout = config.timeout
        self.auto_reconnect = config.auto_reconnect
        self.reconnect_interval = config.reconnect_interval
        self.max_reconnect_attempts = config.max_reconnect_attempts
        
        self.serial_connection = None
        self.is_monitoring = False
        self.connected = False
        self.should_stop = False
        self.reconnect_attempts = 0
        
        logger.info(f" SimpleSerial initialized for port: {self.port} (baudrate: {self.baudrate})")
    
    def connect(self) -> bool:
        """Establish serial connection"""
        try:
            import serial
            
            # Close existing connection if any
            if self.serial_connection and self.serial_connection.is_open:
                self.serial_connection.close()
            
            self.serial_connection = serial.Serial(
                port=self.port,
                baudrate=self.baudrate,
                timeout=self.timeout
            )
            self.connected = True
            self.reconnect_attempts = 0  # Reset reconnect attempts on successful connection
            self.connection_status_changed.emit(True)
            logger.info(f" Serial connected to {self.port}")
            return True
        except Exception as e:
            self.connected = False
            self.connection_status_changed.emit(False)
            error_msg = f" Failed to connect to {self.port}: {e}"
            logger.error(error_msg)
            self.error_occurred.emit(error_msg)
            return False
    
    def disconnect(self):
        """Close serial connection"""
        self.is_monitoring = False
        self.should_stop = True  # Signal thread to stop
        if self.serial_connection and self.serial_connection.is_open:
            try:
                self.serial_connection.close()
                self.connected = False
                self.connection_status_changed.emit(False)
                logger.info(f" Serial disconnected from {self.port}")
            except Exception as e:
                logger.warning(f"Ô∏è  Error disconnecting serial: {e}")
    
    def reconnect(self) -> bool:
        """Attempt to reconnect to serial port"""
        if self.should_stop:
            return False
            
        self.reconnect_attempts += 1
        max_attempts = self.max_reconnect_attempts
        
        if max_attempts > 0 and self.reconnect_attempts > max_attempts:
            logger.error(f" Maximum reconnection attempts ({max_attempts}) reached for {self.port}")
            self.error_occurred.emit(f"Maximum reconnection attempts reached")
            return False
        
        logger.info(f" Attempting to reconnect to {self.port} (attempt {self.reconnect_attempts})")
        return self.connect()
    
    def force_reconnect(self) -> bool:
        """Force a reconnection by resetting attempt counter"""
        self.reconnect_attempts = 0
        return self.reconnect()
    
    def read_line(self) -> str | None:
        """Read a single line from serial port - BIDIRECTIONAL"""
        if not self.serial_connection or not self.serial_connection.is_open:
            return None
        
        try:
            if self.serial_connection.in_waiting > 0:
                line = self.serial_connection.readline().decode('utf-8', errors='ignore').strip()
                if line:
                    logger.debug(f"üì• [BIDIRECTIONAL] RECEIVED: {line}")
                return line if line else None
        except Exception as e:
            logger.warning(f"Ô∏è  Error reading serial data: {e}")
            return None
        
        return None
    
    def send_data(self, data: str) -> bool:
        """Send data via serial port - BIDIRECTIONAL COMMUNICATION"""
        if not self.serial_connection or not self.serial_connection.is_open:
            logger.warning("Ô∏è  Cannot send data: serial connection not open")
            return False
        
        try:
            # # stop\n\n
            # if data.lower() == "stop":
            #     data += '\n'
            #     data += '\n'
            # # Add newline if not present
            # if not data.endswith('\n'):
            #     data += '\n'

           
            
            # BIDIRECTIONAL: Send data while still able to receive
            # logger.info()
            # self.serial_connection.write(data.encode("utf-8"))
            data_bytes = bytearray(data, 'utf-8')
            self.serial_connection.write(data_bytes)
            self.serial_connection.flush()  # Ensure data is sent immediately
            
            logger.debug(f"üì§ [BIDIRECTIONAL] SENT: {data.strip()}")
            return True
            
        except Exception as e:
            logger.error(f" Error sending serial data: {e}")
            return False
    
    def start_monitoring(self):
        """Start monitoring serial data and send start signal - WAIT FOR OK RESPONSE"""
        self.is_monitoring = True
        
        # BIDIRECTIONAL: Send "Start" signal via serial and wait for OK response
        if self.send_data("Start\n"):
            logger.info("üì§ Serial monitoring started - sent 'Start' signal, waiting for 'OK' response...")
            
            # Wait for OK response for up to 5 seconds
            import time
            start_time = time.time()
            ok_received = False
            
            
            if self.serial_connection and self.serial_connection.in_waiting > 0:
                try:
                    response = self.serial_connection.readline().strip()
                    if response:
                        logger.info(f"üì• Received response: '{response}'")
                        if response.upper() == "OK":
                            ok_received = True
                            logger.info("‚úÖ Received 'OK' - serial communication confirmed!")
                            
                        else:
                            logger.warning(f"‚ö†Ô∏è Expected 'OK' but received: '{response}'")
                except Exception as e:
                    logger.error(f"‚ùå Error reading OK response: {e}")
                        
                
            
            if not ok_received:
                logger.warning("‚ö†Ô∏è Did not receive 'OK' response within 5 seconds - continuing anyway")
        else:
            logger.warning("Ô∏è‚ùå Serial monitoring started but failed to send start signal")
        
        logger.info("üöÄ Serial monitoring started (BIDIRECTIONAL) - ready to receive scores and events")
    
    def stop_monitoring(self):
        """Stop monitoring serial data and send stop signal - WAIT FOR OK RESPONSE"""
        self.is_monitoring = False
        
        # BIDIRECTIONAL: Send "Stop" signal via serial and wait for OK response
        if self.send_data("Stop\n\n"):
            logger.info("üì§ Serial monitoring stopped - sent 'Stop' signal, waiting for 'OK' response...")
            
            # Wait for OK response for up to 3 seconds
            import time
            start_time = time.time()
            ok_received = False
            
            while time.time() - start_time < .1 and not ok_received:
                if self.serial_connection and self.serial_connection.in_waiting > 0:
                    try:
                        response = self.serial_connection.readline().decode('utf-8', errors='ignore').strip()
                        if response:
                            logger.info(f"üì• Received response: '{response}'")
                            if response.upper() == "OK":
                                ok_received = True
                                logger.info("‚úÖ Received 'OK' - stop confirmed!")
                                break
                            else:
                                logger.warning(f"‚ö†Ô∏è Expected 'OK' but received: '{response}'")
                    except Exception as e:
                        logger.error(f"‚ùå Error reading OK response: {e}")
                        break
                
            
            if not ok_received:
                logger.warning("‚ö†Ô∏è Did not receive 'OK' response for stop within 3 seconds")
        else:
            logger.warning("Ô∏è‚ùå Serial monitoring stopped but failed to send stop signal")
        
        logger.info("üõë Serial monitoring stopped (BIDIRECTIONAL)")
    
    def run(self):
        """Main thread loop for reading serial data with automatic reconnection"""
        logger.info(" SimpleSerial thread started")
        
        # Try initial connection
        if not self.connect():
            if self.auto_reconnect:
                logger.info(" Initial connection failed, will attempt reconnection")
            else:
                logger.error(" Initial connection failed and auto-reconnect is disabled")
                return
        
        while not self.should_stop:
            try:
                if self.connected and self.is_monitoring:
                    data = self.read_line()
                    # data expected:
                    # Sc{score}\n
                    # Mstk\n
                    # Ok\n
                    # Crct\n
                    # Miss\n
                    if data:
                        logger.info(f" Serial data received: {data}")
                        self.data_received.emit(data)
                elif not self.connected and self.auto_reconnect:
                    # Attempt reconnection
                    logger.debug(f" Connection lost, waiting {self.reconnect_interval}s before reconnection attempt")
                    self.msleep(self.reconnect_interval * 1000)  # Convert to milliseconds
                    
                    if not self.should_stop:  # Check again after sleep
                        if not self.reconnect():
                            # If reconnect failed and we've exceeded max attempts, stop trying
                            if (self.max_reconnect_attempts > 0 and 
                                self.reconnect_attempts >= self.max_reconnect_attempts):
                                logger.error(" Giving up on reconnection attempts")
                                break
                
                # Small delay to prevent excessive CPU usage
                self.msleep(50)
                
            except Exception as e:
                logger.error(f" Error in serial thread loop: {e}")
                self.error_occurred.emit(str(e))
                self.connected = False
                self.connection_status_changed.emit(False)
                
                # If auto-reconnect is disabled, break the loop
                if not self.auto_reconnect:
                    break
        
        # Cleanup
        self.disconnect()
        logger.info(" SimpleSerial thread stopped")
    
    def stop(self):
        """Safely stop the serial thread"""
        logger.debug(" Stopping SimpleSerial thread...")
        
        self.should_stop = True
        self.is_monitoring = False
        self.connected = False
        
        # Close serial connection
        self.disconnect()
        
        # Wait for thread to finish
        if self.isRunning():
            if not self.wait(3000):  # Wait 3 seconds
                logger.warning("Ô∏è  SimpleSerial thread did not finish gracefully")
                self.terminate()
                self.wait()
        
        logger.debug(" SimpleSerial thread stopped successfully")
    
    def send_score_update(self, score: int) -> bool:
        """Send score update via serial - BIDIRECTIONAL"""
        return self.send_data(f"Sc{score}")
    
    def send_game_event(self, event: str) -> bool:
        """Send game event (Miss, Ok, Crct, Mstk) via serial - BIDIRECTIONAL"""
        return self.send_data(event)
    
    def get_status(self) -> dict:
        """Get current connection status and configuration"""
        return {
            'connected': self.connected,
            'monitoring': self.is_monitoring,
            'port': self.port,
            'baudrate': self.baudrate,
            'auto_reconnect': self.auto_reconnect,
            'reconnect_attempts': self.reconnect_attempts,
            'max_reconnect_attempts': self.max_reconnect_attempts,
            'should_stop': self.should_stop
        }
    
    

class MqttThread(QThread):
    message_signal = pyqtSignal(str)
    start_signal = pyqtSignal()
    stop_signal = pyqtSignal()
    restart_signal = pyqtSignal()
    activate_signal = pyqtSignal()
    deactivate_signal = pyqtSignal()

    def __init__(self, broker='localhost', port=1883):
        super().__init__()
        mqtt_config = config.settings.mqtt
        self.data_topics = mqtt_config.data_topics
        self.control_topics = mqtt_config.control_topics
        self.broker = mqtt_config.broker
        self.port = mqtt_config.port
        # Fix MQTT deprecation warning by using callback_api_version
        self.client = mqtt.Client(callback_api_version=mqtt.CallbackAPIVersion.VERSION2)
        self.subscribed = False

    def run(self):
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        self.client.connect(self.broker, self.port)
        self.client.loop_forever()

    def on_connect(self, client, userdata, flags, rc, properties=None):
        for topic in self.control_topics:
            client.subscribe(topic)

    def on_message(self, client, userdata, msg, properties=None):
        print(f"Received message '{msg.payload.decode()}' on topic '{msg.topic}'")

        if msg.topic == "FastReaction/game/start":
            self.handle_start()
        elif msg.topic == "FastReaction/game/Activate":
            self.handle_Activate()
        elif msg.topic == "FastReaction/game/Deactivate":
            self.deactivate_signal.emit()
        elif msg.topic == "FastReaction/game/stop":
            if msg.payload.decode() == "0":
                self.handle_stop()
            elif msg.payload.decode() == "1":
                self.unsubscribe_from_data_topics()
        elif msg.topic == "FastReaction/game/restart":
            print("Game restarted")
            self.handle_restart()
        elif msg.topic == "FastReaction/game/timer":
            global TimerValue
            TimerValue = int(msg.payload.decode())*1000
            print(TimerValue)
            with open("file2.txt", "w") as file:
                file.write(f"{TimerValue}\n")
        elif msg.topic == "FastReaction/game/timerfinal":
            global final_screen_timer_idle
            final_screen_timer_idle = int(msg.payload.decode())*1000
            print(final_screen_timer_idle)
            with open("file.txt", "w") as file:
                file.write(f"{final_screen_timer_idle}\n")
        else:
            if self.subscribed:
                self.handle_data_message(msg)

    def handle_data_message(self, msg):
        data = msg.payload.decode()
        self.message_signal.emit(data)

    def handle_restart(self):
        print("Game restarted")
        self.subscribe_to_data_topics()
        self.restart_signal.emit()     

    def handle_start(self):
        print("Game started")
        self.subscribe_to_data_topics()
        self.start_signal.emit()

    def handle_Activate(self):
        print("Game Activated")
        self.activate_signal.emit()

    def handle_stop(self):
        print("Game stopped")
        self.unsubscribe_from_data_topics()
        self.stop_signal.emit()
   
    def subscribe_to_data_topics(self):
        if not self.subscribed:
            for topic in self.data_topics:
                self.client.subscribe(topic)
            self.subscribed = True

    def unsubscribe_from_data_topics(self):
        if self.subscribed:
            for topic in self.data_topics:
                self.client.unsubscribe(topic)
            self.subscribed = False
    
    def stop(self):
        """Safely stop the MQTT thread and cleanup resources"""
        logger.debug(" Stopping MqttThread...")
        
        try:
            # Unsubscribe from all topics first
            if hasattr(self, 'client') and self.client:
                try:
                    # Unsubscribe from data topics
                    if self.subscribed:
                        for topic in self.data_topics:
                            self.client.unsubscribe(topic)
                        self.subscribed = False
                    
                    # Unsubscribe from control topics
                    for topic in self.control_topics:
                        self.client.unsubscribe(topic)
                    
                    logger.debug(" Unsubscribed from all MQTT topics")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error unsubscribing from topics: {e}")
                
                try:
                    # Disconnect the MQTT client gracefully
                    self.client.loop_stop()  # Stop the network loop
                    self.client.disconnect()  # Disconnect from broker
                    logger.debug(" MQTT client disconnected")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error disconnecting MQTT client: {e}")
                
                self.client = None
        
        except Exception as e:
            logger.warning(f"Ô∏è  Error in MQTT cleanup: {e}")
        
        # Wait for thread to finish gracefully
        if self.isRunning():
            if not self.wait(3000):  # Wait 3 seconds
                logger.warning("Ô∏è  MqttThread did not finish gracefully")
                # Only terminate as last resort
                self.terminate()
                self.wait()
        
        logger.debug(" MqttThread stopped successfully")
    
    def run(self):
        """Run MQTT client with proper error handling and cleanup support"""
        try:
            self.client.on_connect = self.on_connect
            self.client.on_message = self.on_message
            self.client.connect(self.broker, self.port)
            self.client.loop_forever()  # This will run until loop_stop() is called
        except Exception as e:
            logger.error(f" MQTT thread error: {e}")
        finally:
            logger.debug(" MQTT thread run() method exiting")


class GameManager(QThread):
    """
    Updated GameManager that uses the new GameAPI
    Handles the complete game flow:
    1. Authentication with API
    2. Poll for game initialization 
    3. Poll for game start
    4. Submit final scores
    """
    init_signal = pyqtSignal()
    start_signal = pyqtSignal()
    cancel_signal = pyqtSignal()
    submit_signal = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        logger.info(" GameManager initializing...")
        
        # Initialize the GameAPI
        try:
            self.api = GameAPI()
            logger.info(" GameAPI initialized successfully")
        except Exception as e:
            logger.error(f" Failed to initialize GameAPI: {e}")
            raise
            
        # Game state
        self.game_result_id = None
        self.submit_score_flag = False
        self.playStatus = True
        self.started_flag = False
        self.cancel_flag = False
        self.game_done = True
        
        logger.info(" GameManager initialized successfully")
        
    def run(self):
        """Main game loop following the proper API flow"""
        logger.info(" GameManager starting main loop...")
        
        while self.playStatus:
            try:
                # Step 1: Authenticate
                logger.info(" Step 1: Authenticating...")
                if not hasattr(self, 'api') or self.api is None:
                    logger.error(" GameAPI not initialized")
                    time.sleep(5)
                    continue
                    
                if not self.api.authenticate():
                    logger.error(" Authentication failed, retrying in 5 seconds...")
                    time.sleep(5)
                    continue
                
                # Step 2: Poll for game initialization
                logger.info(" Step 2: Polling for game initialization...")
                if not self._poll_initialization():
                    continue
                
                # Step 3: Poll for game start
                logger.info(" Step 3: Polling for game start...")
                if not self._poll_game_start():
                    continue
                
                # Step 4: Wait for game completion and submit scores
                logger.info(" Step 4: Waiting for game completion...")
                if not self._wait_and_submit_scores():
                    continue
                    
            except Exception as e:
                logger.error(f" Error in game loop: {e}")
                time.sleep(5)
                continue
    
    def _poll_initialization(self) -> bool:
        """Poll for game initialization"""
        while self.playStatus:
            try:
                if not hasattr(self, 'api') or self.api is None:
                    logger.error(" GameAPI not available for initialization polling")
                    return False
                    
                game_data = self.api.poll_game_initialization()
                if game_data:
                    self.game_result_id = game_data.get('id')
                    
                    # Extract team and player information
                    global teamName, list_players_name, list_players_id
                    teamName = game_data.get('name', 'Unknown Team')
                    
                    # Extract player info from nodeIDs
                    node_ids = game_data.get('nodeIDs', [])
                    list_players_name = [player.get('name', f'Player {i+1}') for i, player in enumerate(node_ids)]
                    list_players_id = [player.get('userID', f'user_{i+1}') for i, player in enumerate(node_ids)]
                    
                    logger.info(f" Game initialized: {self.game_result_id}")
                    logger.info(f" Team: {teamName}")
                    logger.info(f" Players: {list_players_name}")
                    
                    # Check if home screen is ready
                    global homeOpened
                    if homeOpened:
                        logger.info(" Home screen ready, emitting init signal")
                        homeOpened = False
                        self.init_signal.emit()
                        return True
                    else:
                        logger.info("‚è≥ Waiting for home screen to be ready...")
                
                time.sleep(3)  # Poll every 3 seconds
                
            except Exception as e:
                logger.error(f" Error polling initialization: {e}")
                time.sleep(5)
                
        return False
    
    def _poll_game_start(self) -> bool:
        """Poll for game start and continue monitoring during gameplay - Like CAGE_Game.py"""
        if not self.game_result_id:
            logger.error(" No game result ID available")
            return False
        
        logger.info(f" Starting polling with started_flag={self.started_flag}, cancel_flag={self.cancel_flag}")
        logger.info(" Starting continuous polling for game start...")
        
        # Create a simple reference object to avoid lambda timing issues
        class FlagRef:
            def __init__(self, manager):
                self.manager = manager
            def __call__(self, value=None):
                if value is not None:
                    self.manager.started_flag = value
                return self.manager.started_flag
        
        flag_ref = FlagRef(self)
        
        try:
            # Check API availability
            if not hasattr(self, 'api') or self.api is None:
                logger.error(" GameAPI not available for game start polling")
                return False
                
            # Phase 1: Wait for game to start using continuous polling like CAGE
            game_data = self.api.poll_game_start_continuous(
                game_result_id=self.game_result_id,
                submit_score_flag_ref=lambda: self.submit_score_flag,
                started_flag_ref=flag_ref,
                cancel_flag_ref=lambda x: setattr(self, 'cancel_flag', x)
            )
            
            if game_data:
                status = game_data.get('status')
                
                if status == 'playing' and not self.started_flag:
                    logger.info(" Game start signal received!")
                    self.start_signal.emit()
                    self.started_flag = True
                    
                    logger.info(" Start signal emitted successfully!")
                    logger.info(" Now subsequent 'playing' responses will be ignored")
                    
                    # Phase 2: Continue monitoring during gameplay
                    logger.info(" Game started - continuing to monitor for cancellation...")
                    return self._monitor_during_gameplay()
                    
                elif status == 'cancel' or game_data.get('cancelled'):
                    logger.warning("Ô∏è  Game cancelled before starting")
                    self.cancel_flag = True
                    # CRITICAL: Reset started_flag IMMEDIATELY before emitting cancel
                    self.started_flag = False
                    logger.warning(f" started_flag reset to False before cancel: {self.started_flag}")
                    self.cancel_signal.emit()
                    # Manual reset of essential flags only
                    self.game_result_id = None
                    self.submit_score_flag = False
                    return False
                elif status == 'submit_triggered':
                    logger.info(" Score submission triggered before game start")
                    return True
                else:
                    logger.warning(f"Ô∏è  Unexpected status: {status}")
                    return False
            else:
                logger.warning("Ô∏è  No game data returned from continuous polling")
                return False
                
        except Exception as e:
            logger.error(f" Error in game start polling: {e}")
            return False
    
    def _monitor_during_gameplay(self) -> bool:
        """Continue monitoring for cancellation during active gameplay (from CAGE)"""
        logger.info(" Monitoring for cancellation during gameplay...")
        
        try:
            # Create a callback to check if game has stopped
            def game_stopped_check():
                # Only check if game has stopped AFTER it has actually started
                # This prevents race condition where polling starts before UI sets gameStarted=True
                global gameStarted
                
                # First, give the UI thread time to process the start signal
                # Only check for stop if we're confident the game was actually running
                import time
                current_time = time.time()
                if not hasattr(game_stopped_check, 'start_time'):
                    game_stopped_check.start_time = current_time
                
                # Only start checking for game stop after 2 seconds of polling
                if current_time - game_stopped_check.start_time < 2.0:
                    return False
                
                # Now check if game has actually stopped (timers stopped)
                if not gameStarted:
                    logger.info(" Game timers stopped (gameStarted=False) - stopping API polling")
                    return True
                    
                return False
            
            # Check API availability
            if not hasattr(self, 'api') or self.api is None:
                logger.error(" GameAPI not available for gameplay monitoring")
                return False
                
            # Continue continuous polling during gameplay with stop check - Like CAGE
            game_data = self.api.poll_game_start_continuous(
                game_result_id=self.game_result_id,
                submit_score_flag_ref=lambda: self.submit_score_flag,
                started_flag_ref=lambda: self.started_flag,
                cancel_flag_ref=lambda x: setattr(self, 'cancel_flag', x),
                game_stopped_check=game_stopped_check
            )
            
            if game_data:
                status = game_data.get('status')
                logger.info(f" Gameplay monitoring completed with status: {status}")
                
                if status == 'cancel' or game_data.get('cancelled'):
                    logger.warning("Ô∏è  Game cancelled during gameplay")
                    self.cancel_flag = True
                    # CRITICAL: Reset started_flag IMMEDIATELY before emitting cancel
                    self.started_flag = False
                    logger.warning(f" started_flag reset to False during gameplay cancel: {self.started_flag}")
                    self.cancel_signal.emit()
                    # Manual reset of essential flags only
                    self.game_result_id = None
                    self.submit_score_flag = False
                    return False
                elif status == 'submit_triggered':
                    logger.info(" Score submission triggered during gameplay")
                    return True
                else:
                    logger.info(f" Gameplay monitoring completed with status: {status}")
                    return True
            else:
                logger.warning("Ô∏è  No game data returned during gameplay monitoring")
                return False
                
        except Exception as e:
            logger.error(f" Error monitoring during gameplay: {e}")
            return False
    
    def _wait_and_submit_scores(self) -> bool:
        """Wait for game completion and submit scores"""
        while self.playStatus and not self.cancel_flag:
            if self.submit_score_flag:
                try:
                    # Prepare individual scores
                    global scored, list_players_id
                    individual_scores = self._prepare_individual_scores(scored, list_players_id)
                    
                    #  SAVE PLAYER DATA TO CSV FIRST (before API submission)
                    logger.info(" Saving FastReaction player data to CSV before API submission...")
                    self._save_individual_players_csv(self.game_result_id, individual_scores, None)  # None = pre-submission
                    self._save_pre_submission_log(self.game_result_id, individual_scores)
                    logger.info(" FastReaction player data saved locally before submission")
                    
                    # Submit scores with API safety check
                    if not hasattr(self, 'api') or self.api is None:
                        logger.error(" GameAPI not available for score submission")
                        return False
                    
                    # Submit scores using original method (keep as main submitter)
                    logger.info(" Now submitting FastReaction scores to API...")
                    success = self.api.submit_final_scores(self.game_result_id, individual_scores)
                    
                    # Save player CSV with final submission status (after API submission)
                    self._save_individual_players_csv(self.game_result_id, individual_scores, success)
                    
                    if success:
                        logger.info(" Scores submitted successfully")
                        # Get updated leaderboard
                        self._update_leaderboard()
                        self.submit_signal.emit()
                        self._reset_game_state()
                        return True
                    else:
                        logger.error(" Failed to submit scores")
                        time.sleep(5)
                        
                except Exception as e:
                    logger.error(f" Error submitting scores: {e}")
                    time.sleep(5)
            else:
                time.sleep(1)  # Check every second for score submission flag
                
        return False
    
    def _prepare_individual_scores(self, total_score: int, player_ids: list) -> list:
        """Prepare individual scores in the required format"""
        if not player_ids:
            logger.warning("Ô∏è  No player IDs available, using default")
            player_ids = ["default_user"]
        
        # Distribute score among players (first player gets any remainder)
        base_score = total_score // len(player_ids)
        remainder = total_score % len(player_ids)
        
        individual_scores = []
        for i, user_id in enumerate(player_ids):
            score = base_score + (remainder if i == 0 else 0)
            individual_scores.append({
                "userID": user_id,
                "nodeID": i + 1,
                "score": score
            })
        
        logger.info(f" Prepared scores for {len(individual_scores)} players")
        return individual_scores
    
    def _save_individual_players_csv(self, game_result_id: str, individual_scores: list, success: bool):
        """Save individual player scores for database revision"""
        try:
            csv_filename = "FastReaction_Individual_Players_Log.csv"
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # Check if file exists to determine if we need headers
            file_exists = os.path.exists(csv_filename)
            
            with open(csv_filename, 'a', newline='', encoding='utf-8') as csvfile:
                fieldnames = [
                    'timestamp', 'game_result_id', 'user_id', 'node_id', 
                    'individual_score', 'submission_success', 'status'
                ]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                # Write header if file is new
                if not file_exists:
                    writer.writeheader()
                    logger.info(f" Created new individual players log file: {csv_filename}")
                
                # Determine status based on success parameter
                if success is None:
                    status = "pre_submission"
                elif success:
                    status = "submitted_success"
                else:
                    status = "submitted_failed"
                
                # Write one row per player
                for score_data in individual_scores:
                    writer.writerow({
                        'timestamp': timestamp,
                        'game_result_id': game_result_id,
                        'user_id': score_data.get('userID', 'Unknown'),
                        'node_id': score_data.get('nodeID', 'N/A'),
                        'individual_score': score_data.get('score', 0),
                        'submission_success': success,
                        'status': status
                    })
                
            if success is None:
                logger.info(f" Player data saved to {csv_filename} BEFORE API submission")
            else:
                logger.info(f" Player data status updated in {csv_filename} AFTER API submission")
            
        except Exception as e:
            logger.error(f" Error saving individual players log to CSV: {e}")
            # Don't let CSV errors break the game flow
    
    def _save_pre_submission_log(self, game_result_id: str, individual_scores: list):
        """Save a pre-submission log entry for safety"""
        try:
            csv_filename = "FastReaction_Pre_Submission_Backup.csv"
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            # Check if file exists to determine if we need headers
            file_exists = os.path.exists(csv_filename)
            
            with open(csv_filename, 'a', newline='', encoding='utf-8') as csvfile:
                fieldnames = [
                    'timestamp', 'game_result_id', 'total_players', 'total_score', 
                    'player_ids', 'individual_scores_json', 'status'
                ]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                # Write header if file is new
                if not file_exists:
                    writer.writeheader()
                    logger.info(f" Created new pre-submission backup file: {csv_filename}")
                
                # Calculate totals
                total_players = len(individual_scores)
                total_score = sum(score_data.get('score', 0) for score_data in individual_scores)
                
                # Create player IDs list
                player_ids = [score_data.get('userID', 'Unknown') for score_data in individual_scores]
                player_ids_str = " | ".join(player_ids)
                
                # Convert individual scores to JSON string for complete backup
                individual_scores_json = json.dumps(individual_scores)
                
                writer.writerow({
                    'timestamp': timestamp,
                    'game_result_id': game_result_id,
                    'total_players': total_players,
                    'total_score': total_score,
                    'player_ids': player_ids_str,
                    'individual_scores_json': individual_scores_json,
                    'status': 'saved_before_submission'
                })
                
            logger.info(f" Pre-submission backup saved to {csv_filename}")
            logger.info(f"    Game ID: {game_result_id}")
            logger.info(f"    Players: {total_players}")
            logger.info(f"    Total Score: {total_score}")
            
        except Exception as e:
            logger.error(f" Error saving pre-submission backup: {e}")
            # Don't let CSV errors break the game flow
    
    def _update_leaderboard(self):
        """Update the leaderboard data"""
        try:
            global list_top5_FastReaction
            leaderboard = self.api.get_leaderboard()
            list_top5_FastReaction.clear()
            list_top5_FastReaction.extend(leaderboard)

            logger.info(f" Leaderboard updated with {len(leaderboard)} entries")
        except Exception as e:
            logger.error(f" Error updating leaderboard: {e}")
    
    def _reset_game_state(self):
        """Reset game state for next round"""
        logger.info(" Resetting game state for next round")
        self.game_result_id = None
        self.submit_score_flag = False
        self.started_flag = False
        self.cancel_flag = False
        
        # Reset global game variables
        global scored, serial_scoring_active
        # scored = 0
        serial_scoring_active = False
    
    def trigger_score_submission(self):
        """Trigger score submission (called when game ends)"""
        logger.info(" Score submission triggered")
        self.submit_score_flag = True
    
    def stop_manager(self):
        """Stop the game manager with comprehensive cleanup"""
        logger.info(" Stopping GameManager...")
        
        try:
            # Stop the game loop
            self.playStatus = False
            
            # Disconnect all signals
            try:
                self.init_signal.disconnect()
                self.start_signal.disconnect()
                self.cancel_signal.disconnect()
                self.submit_signal.disconnect()
                logger.debug(" GameManager signals disconnected")
            except Exception as e:
                logger.warning(f"Ô∏è  Error disconnecting signals: {e}")
            
            # Clean up API object
            if hasattr(self, 'api') and self.api:
                try:
                    # The GameAPI object doesn't have explicit cleanup,
                    # but we can clear the reference
                    self.api = None
                    logger.debug(" GameAPI reference cleared")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error cleaning API: {e}")
            
            # Reset game state
            try:
                self._reset_game_state()
                logger.debug(" Game state reset")
            except Exception as e:
                logger.warning(f"Ô∏è  Error resetting game state: {e}")
        
        except Exception as e:
            logger.warning(f"Ô∏è  Error in GameManager cleanup: {e}")
        
        # Stop the thread gracefully
        try:
            self.quit()
            if not self.wait(5000):  # Wait up to 5 seconds
                logger.warning("Ô∏è  GameManager thread did not finish gracefully")
                # Don't use terminate() unless absolutely necessary
            logger.debug(" GameManager stopped successfully")
        except Exception as e:
            logger.warning(f"Ô∏è  Error stopping GameManager thread: {e}")


class Final_Screen(QtWidgets.QMainWindow):
    """Complete Final Screen implementation"""
    
    def load_custom_font(self, font_path):
        font_id = QtGui.QFontDatabase.addApplicationFont(font_path)
        if font_id == -1:
            print(f"Failed to load font: {font_path}")
            return "Default"
        font_families = QtGui.QFontDatabase.applicationFontFamilies(font_id)
        if font_families:
            return font_families[0]
        return "Default"
    
    def showTable(self):
        if hasattr(self, 'Label'):
            self.Label.hide()
        self.Label2.show()
        self.Label_team_name.show()
        self.LeaderboardTable.show()
        self.UpdateTable()
    
    def TimerWidget(self, centralwidget):
        self.Countdown = QtWidgets.QWidget(centralwidget)
        self.Label = QtWidgets.QLabel(centralwidget)
    
    def hideTable(self):
        if hasattr(self, 'Label2'):
            self.Label2.hide()
        if hasattr(self, 'Label_team_name'):
            self.Label_team_name.hide()
        if hasattr(self, 'LeaderboardTable'):
            self.LeaderboardTable.hide()

    def setupTimer(self):
        # Start the GIF
        pass
    
    def setupUi(self, Home):
        Home.setObjectName("Home")
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        Home.setLayoutDirection(QtCore.Qt.LeftToRight)
        Home.setAutoFillBackground(False)
        
        self.centralwidget = QtWidgets.QWidget(Home)
        # Home.setGeometry(0, 0, QtWidgets.QDesktopWidget().screenGeometry().width(), QtWidgets.QDesktopWidget().screenGeometry().height())
        Home.setGeometry(0, 0, 3840, 2160)
        print(Home.geometry().width())
        self.font_family = self.load_custom_font("Assets/Fonts/GOTHIC.TTF")
        self.font_family_good = self.load_custom_font("Assets/Fonts/good_times_rg.ttf")

        if Home.geometry().width() > 1920:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_final.png")
            self.scale = 2
        else:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_final.png")
            self.scale = 1
        
        self.Background = QtWidgets.QLabel(self.centralwidget)
        self.Background.setScaledContents(True)
        self.Background.setGeometry(0, 0, Home.geometry().width(), Home.geometry().height())
        self.Background.setText("")
        self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.Background.setPixmap(self.background_pixmap)
        self.Background.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        
        self.TimerWidget(self.centralwidget)
        
        # Score label
        self.Label2 = QtWidgets.QLabel(self.centralwidget)
        self.Label2.setGeometry(QtCore.QRect(303*self.scale, 609*self.scale, 390*self.scale, 122*self.scale))
        global scored
        self.Label2.setText(str(scored))
        self.Label2.setAlignment(QtCore.Qt.AlignCenter)
        font = QtGui.QFont()
        font.setPointSize(39*self.scale)
        font.setFamily(self.font_family_good)
        self.Label2.setFont(font)
        self.Label2.setStyleSheet("color: rgb(255, 255, 255);")
        self.Label2.hide()
        self.Label2.raise_()
        
        # Team name label
        self.Label_team_name = QtWidgets.QLabel(self.centralwidget)
        self.Label_team_name.setGeometry(QtCore.QRect(108*self.scale, 452*self.scale, 780*self.scale, 122*self.scale))
        global teamName
        self.Label_team_name.setText(teamName)
        self.Label_team_name.setAlignment(QtCore.Qt.AlignCenter)
        font_team = QtGui.QFont()
        font_team.setPointSize(40*self.scale)
        font_team.setFamily(self.font_family_good)
        self.Label_team_name.setFont(font_team)
        self.Label_team_name.setStyleSheet("color: rgb(255, 255, 255);")
        self.Label_team_name.hide()
        self.Label_team_name.raise_()
        
        # Create leaderboard table
        self.frame_2 = QtWidgets.QFrame(self.centralwidget)
        self.frame_2.setGeometry(QtCore.QRect(1009*self.scale, 359*self.scale, 802*self.scale, 595*self.scale))
        self.gridLayout = QtWidgets.QGridLayout(self.frame_2)
        self.LeaderboardTable = QtWidgets.QTableWidget(self.frame_2)
        self.LeaderboardTable.setRowCount(5)
        self.LeaderboardTable.setColumnCount(2)
        
        # Set up table properties
        font = QtGui.QFont()
        font.setFamily(self.font_family_good)
        font.setPointSize(22*self.scale)
        font.setBold(False)
        font.setItalic(False)
        self.LeaderboardTable.setFont(font)
        self.LeaderboardTable.setFocusPolicy(QtCore.Qt.NoFocus)
        self.LeaderboardTable.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.LeaderboardTable.setAutoFillBackground(False)
        self.LeaderboardTable.setLineWidth(0)
        self.LeaderboardTable.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.LeaderboardTable.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.LeaderboardTable.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.LeaderboardTable.setAutoScroll(False)
        self.LeaderboardTable.setAutoScrollMargin(0)
        self.LeaderboardTable.setProperty("showDropIndicator", False)
        self.LeaderboardTable.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.LeaderboardTable.setTextElideMode(QtCore.Qt.ElideLeft)
        self.LeaderboardTable.setShowGrid(False)
        self.LeaderboardTable.setGridStyle(QtCore.Qt.NoPen)
        self.LeaderboardTable.setWordWrap(True)
        self.LeaderboardTable.setCornerButtonEnabled(True)
        self.LeaderboardTable.setObjectName("LeaderboardTable")
        
        # Custom palette configuration for LeaderboardTable - consistent across all states
        palette = QtGui.QPalette()
        
        # Define color scheme once
        white_text = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        white_text.setStyle(QtCore.Qt.SolidPattern)
        transparent_bg = QtGui.QBrush(QtGui.QColor(0, 0, 0, 0))
        transparent_bg.setStyle(QtCore.Qt.SolidPattern)
        light_blue = QtGui.QBrush(QtGui.QColor(102, 171, 255))
        light_blue.setStyle(QtCore.Qt.SolidPattern)
        mid_blue = QtGui.QBrush(QtGui.QColor(65, 142, 235))
        mid_blue.setStyle(QtCore.Qt.SolidPattern)
        dark_blue = QtGui.QBrush(QtGui.QColor(14, 57, 108))
        dark_blue.setStyle(QtCore.Qt.SolidPattern)
        medium_blue = QtGui.QBrush(QtGui.QColor(19, 75, 144))
        medium_blue.setStyle(QtCore.Qt.SolidPattern)
        no_brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        no_brush.setStyle(QtCore.Qt.NoBrush)
        black_shadow = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        black_shadow.setStyle(QtCore.Qt.SolidPattern)
        alt_blue = QtGui.QBrush(QtGui.QColor(141, 184, 235))
        alt_blue.setStyle(QtCore.Qt.SolidPattern)
        tooltip_bg = QtGui.QBrush(QtGui.QColor(255, 255, 220))
        tooltip_bg.setStyle(QtCore.Qt.SolidPattern)
        disabled_alt_blue = QtGui.QBrush(QtGui.QColor(28, 113, 216))
        disabled_alt_blue.setStyle(QtCore.Qt.SolidPattern)
        
        # Apply IDENTICAL styling to ALL states (Active, Inactive, Disabled)
        for state in [QtGui.QPalette.Active, QtGui.QPalette.Inactive, QtGui.QPalette.Disabled]:
            palette.setBrush(state, QtGui.QPalette.WindowText, white_text)
            palette.setBrush(state, QtGui.QPalette.Button, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.Light, light_blue)
            palette.setBrush(state, QtGui.QPalette.Midlight, mid_blue)
            palette.setBrush(state, QtGui.QPalette.Dark, dark_blue)
            palette.setBrush(state, QtGui.QPalette.Mid, medium_blue)
            palette.setBrush(state, QtGui.QPalette.Text, white_text)
            palette.setBrush(state, QtGui.QPalette.BrightText, white_text)
            palette.setBrush(state, QtGui.QPalette.ButtonText, white_text)
            palette.setBrush(state, QtGui.QPalette.Base, no_brush)
            palette.setBrush(state, QtGui.QPalette.Window, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.Shadow, black_shadow)
            palette.setBrush(state, QtGui.QPalette.Highlight, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.HighlightedText, white_text)
            palette.setBrush(state, QtGui.QPalette.ToolTipBase, tooltip_bg)
            palette.setBrush(state, QtGui.QPalette.ToolTipText, black_shadow)
            palette.setBrush(state, QtGui.QPalette.PlaceholderText, white_text)
            
            # Use different AlternateBase for disabled state
            if state == QtGui.QPalette.Disabled:
                palette.setBrush(state, QtGui.QPalette.AlternateBase, disabled_alt_blue)
            else:
                palette.setBrush(state, QtGui.QPalette.AlternateBase, alt_blue)
        
        self.LeaderboardTable.setPalette(palette)
        
        # Gradient palette styling to match the provided image
        self.LeaderboardTable.setStyleSheet("""
            /* QTableWidget Styling - Gradient Blue Palette */
            QTableWidget {
                background: transparent;
                color: #ffffff;  /* White text color */
                gridline-color: rgba(255, 255, 255, 100);  /* Semi-transparent white gridlines */
                selection-background-color: rgba(255, 255, 255, 50);  /* Light selection */
                selection-color: #ffffff;  /* White selection text */
                border: none;  /* No border */
                border-radius: 10px;  /* Rounded corners */
                padding: 8px;
                margin: 4px;
            }

            QHeaderView::section { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 140),      /* #142849 with 55% transparency for headers */
                    stop:0.5 rgba(107, 53, 39, 140),   /* #6b3527 with 55% transparency */
                    stop:1 rgba(181, 102, 59, 140));   /* #b5663b with 55% transparency */
                color: #ffffff;  /* White text color for header sections */
                padding: 12px;  /* Increased padding for header sections */
                border: none;  /* No border */
                border-radius: 5px;  /* Rounded header corners */
                font-weight: bold;  /* Bold font for headers */
                font-family: """ + self.font_family_good + """;  /* Same font as table */
                font-size: """ + str(int(26*self.scale)) + """px;  /* Larger font size */
                margin: 2px;
            }

            QHeaderView {
                background-color: transparent;  /* Transparent background */
                border: none;
            }

            QTableCornerButton::section {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 140),      /* #142849 with 55% transparency */
                    stop:0.5 rgba(107, 53, 39, 140),   /* #6b3527 with 55% transparency */
                    stop:1 rgba(181, 102, 59, 140));   /* #b5663b with 55% transparency */
                border: none;  /* No border */
                border-radius: 5px;
            }

            QTableWidget::item {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 102),      /* #142849 with 40% transparency */
                    stop:0.5 rgba(107, 53, 39, 102),   /* #6b3527 with 40% transparency */
                    stop:1 rgba(181, 102, 59, 102));   /* #b5663b with 40% transparency */
                padding: 8px;  /* More padding for items */
                border: none;  /* No border for items */
                color: #ffffff;  /* White text color */
                background: rgba(255, 255, 255, 20);  /* Very subtle background */
                margin: 1px;
                border-radius: 3px;
            }

            QTableWidget::item:selected {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 100),
                    stop:1 rgba(20, 40, 73, 150));     /* #142849 for selected */
                color: #ffffff;  /* White text for selected items */
                border: none;  /* No border */
            }

            QTableWidget::item:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 80),
                    stop:1 rgba(107, 53, 39, 150));    /* #6b3527 for hover */
                color: #ffffff;  /* White text on hover */
                border: none;  /* No border */
            }

            QTableWidget::item:focus {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 120),
                    stop:1 rgba(181, 102, 59, 180));   /* #b5663b for focus */
                color: #ffffff;  /* White text on focus */
                border: none;  /* No border */
            }
        """)
        
        # Create table items with enhanced properties
        for i in range(5):
            for j in range(2):
                item = QtWidgets.QTableWidgetItem()
                if j == 0:
                    item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                else:
                    item.setTextAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
                self.LeaderboardTable.setItem(i, j, item)
        
        # Set horizontal headers with custom properties
        self.LeaderboardTable.setHorizontalHeaderLabels(["Team", "Score"])
        self.LeaderboardTable.horizontalHeader().setVisible(True)
        self.LeaderboardTable.horizontalHeader().setCascadingSectionResizes(False)
        
        # Calculate column widths for the new table width (802px)
        # Account for table padding (8px), margin (4px), and border (2px) on each side
        # Total padding: (8+4+2) * 2 = 28px, plus some extra buffer for internal spacing
        available_width = int(802 * self.scale - 50)  # More conservative padding calculation
        team_column_width = int(available_width * 0.60)    # 60% for team name
        score_column_width = int(available_width * 0.40)   # 40% for score
        
        # Set the first column to a fixed width, let the second column stretch
        self.LeaderboardTable.horizontalHeader().resizeSection(0, team_column_width)
        self.LeaderboardTable.horizontalHeader().setStretchLastSection(True)
        # Alternative: use section resize mode for better control
        from PyQt5.QtWidgets import QHeaderView
        self.LeaderboardTable.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.LeaderboardTable.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.LeaderboardTable.verticalHeader().setVisible(False)
        self.LeaderboardTable.verticalHeader().setCascadingSectionResizes(False)
        
        # Calculate row heights for the new table height (595px)
        # Total available height: 595px minus header and padding
        available_height = int(595 * self.scale - 100)  # Account for header and padding
        row_height = int(available_height / 5)  # Distribute equally among 5 rows
        
        for i in range(5):
            self.LeaderboardTable.verticalHeader().resizeSection(i, row_height)
        self.LeaderboardTable.verticalHeader().setStretchLastSection(True)
        
        self.gridLayout.addWidget(self.LeaderboardTable, 0, 0, 1, 1)
        
        Home.setCentralWidget(self.centralwidget)
        self.timer = QTimer(Home)
        self.timer2 = QTimer(Home)
        self.setupTimer()
        self.UpdateTable()
        self.showTable()
        
        self.retranslateUi(Home)
        QtCore.QMetaObject.connectSlotsByName(Home)
    
    def retranslateUi(self, Home):
        _translate = QtCore.QCoreApplication.translate
        Home.setWindowTitle(_translate("Home", "MainWindow"))
        item = self.LeaderboardTable.horizontalHeaderItem(0)
        item.setText(_translate("Home", "Team"))
        item = self.LeaderboardTable.horizontalHeaderItem(1)
        item.setText(_translate("Home", "Score"))

    def UpdateTable(self):
        global list_top5_FastReaction
        sorted_data = sorted(list_top5_FastReaction, key=lambda item: item[1], reverse=True)
        
        for i, (team, score) in enumerate(sorted_data):
            if i >= 5:
                break

            team_item = QtWidgets.QTableWidgetItem(team)
            team_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.LeaderboardTable.setItem(i, 0, team_item)

            score_item = QtWidgets.QTableWidgetItem(str(score))
            score_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.LeaderboardTable.setItem(i, 1, score_item)
    
    def closeEvent(self, event):
        logger.info(" Final screen closing...")
        
        
        # Safely stop timers (if they exist)
        if hasattr(self, 'timer') and self.timer:
            try:
                self.timer.stop()
                # Disconnect all signals
                try:
                    self.timer.timeout.disconnect()
                except:
                    pass
                self.timer = None
                logger.debug(" Timer cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping timer: {e}")
        
        if hasattr(self, 'timer2') and self.timer2:
            try:
                self.timer2.stop()
                # Disconnect all signals
                try:
                    self.timer2.timeout.disconnect()
                except:
                    pass
                self.timer2 = None
                logger.debug(" Timer2 cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping timer2: {e}")
        
        # Clean up table widget with safe Qt object handling
        try:
            if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable is not None:
                try:
                    self.LeaderboardTable.hide()
                    self.LeaderboardTable.clear()
                    self.LeaderboardTable.deleteLater()
                    logger.debug(" Table widget cleaned up")
                except (RuntimeError, AttributeError):
                    logger.debug("Table widget already deleted by Qt, skipping cleanup")
                finally:
                    self.LeaderboardTable = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Table widget reference already invalid, skipping cleanup")
            self.LeaderboardTable = None
        
        # Clean up frame with safe Qt object handling
        try:
            if hasattr(self, 'frame_2') and self.frame_2 is not None:
                try:
                    self.frame_2.hide()
                    self.frame_2.deleteLater()
                    logger.debug(" Frame cleaned up")
                except (RuntimeError, AttributeError):
                    logger.debug("Frame already deleted by Qt, skipping cleanup")
                finally:
                    self.frame_2 = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Frame reference already invalid, skipping cleanup")
            self.frame_2 = None
        
        # Clean up labels with safe Qt object handling
        for label_name in ['Label2', 'Label_team_name', 'Label', 'Countdown']:
            try:
                if hasattr(self, label_name):
                    label_obj = getattr(self, label_name)
                    if label_obj is not None:
                        try:
                            label_obj.hide()
                            label_obj.deleteLater()
                            logger.debug(f" {label_name} cleaned up")
                        except (RuntimeError, AttributeError):
                            logger.debug(f"{label_name} already deleted by Qt, skipping cleanup")
                        finally:
                            setattr(self, label_name, None)
            except (RuntimeError, SystemError, AttributeError):
                logger.debug(f"{label_name} reference already invalid, skipping cleanup")
                setattr(self, label_name, None)
        
        # Safely clear background with safe Qt object handling
        try:
            if hasattr(self, 'Background') and self.Background is not None:
                try:
                    self.Background.clear()
                    self.Background.setPixmap(QPixmap())  # Remove pixmap reference
                    self.Background.deleteLater()
                    logger.debug(" Background cleared")
                except (RuntimeError, AttributeError):
                    logger.debug("Background already deleted by Qt, skipping cleanup")
                finally:
                    self.Background = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Background reference already invalid, skipping cleanup")
            self.Background = None
        
        # Clean up central widget and all its children with safe Qt object handling
        try:
            if hasattr(self, 'centralwidget') and self.centralwidget is not None:
                try:
                    # Clean up all child widgets
                    for child in self.centralwidget.findChildren(QtCore.QObject):
                        child.deleteLater()
                    self.centralwidget.deleteLater()
                    logger.debug(" Central widget cleaned up")
                except (RuntimeError, AttributeError):
                    logger.debug("Central widget already deleted by Qt, skipping cleanup")
                finally:
                    self.centralwidget = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Central widget reference already invalid, skipping cleanup")
            self.centralwidget = None
        
        event.accept()
        logger.info(" Final screen closed successfully with complete cleanup")
        super().closeEvent(event)


class Active_screen(QWidget):
    """Complete Active Screen implementation"""
    # signals for Miss OK Crct Mstk
    miss_signal = pyqtSignal()
    ok_signal = pyqtSignal()
    crct_signal = pyqtSignal()
    mstk_signal = pyqtSignal()
    def __init__(self, serial_thread=None):
        super().__init__()
        
        # Initialize MQTT thread
        self.mqtt_thread = MqttThread('localhost')
        self.mqtt_thread.start_signal.connect(self.start_game)
        self.mqtt_thread.stop_signal.connect(self.stop_game)
        self.mqtt_thread.restart_signal.connect(self.restart_game)
        self.mqtt_thread.start()
        
        # Store reference to serial thread (managed by MainApp)
        self.serial_thread = serial_thread
        if self.serial_thread:
            # Connect to serial signals
            try:
                self.serial_thread.data_received.connect(self.on_serial_data_received)
                self.serial_thread.connection_status_changed.connect(self.on_serial_connection_status_changed)
                self.serial_thread.error_occurred.connect(self.on_serial_error)
                logger.info(" Serial signals connected to Active_screen")
            except Exception as e:
                logger.warning(f"Ô∏è  Failed to connect serial signals: {e}")
        
        # self.player = QMediaPlayer()
        
        # Initialize circular timer backend
        self.circular_timer_backend = CircularTimerBackend()
        
        # Track circular timer widget initialization state
        self.circular_timer_initialized = False
        
    def init_mqtt_thread(self):
        """Initialize or reinitialize MQTT thread if needed"""
        try:
            if not hasattr(self, 'mqtt_thread') or self.mqtt_thread is None:
                logger.info(" Initializing MQTT thread...")
                self.mqtt_thread = MqttThread('localhost')
                self.mqtt_thread.start_signal.connect(self.start_game)
                self.mqtt_thread.stop_signal.connect(self.stop_game)
                self.mqtt_thread.restart_signal.connect(self.restart_game)
                self.mqtt_thread.start()
                logger.info(" MQTT thread initialized successfully")
            elif not self.mqtt_thread.isRunning():
                logger.info(" Starting existing MQTT thread...")
                self.mqtt_thread.start()
                logger.info(" MQTT thread started successfully")
            else:
                logger.debug(" MQTT thread already running")
        except Exception as e:
            logger.error(f" Error initializing MQTT thread: {e}")
            
    def init_circular_timer_widget(self, parent_widget):
        """Initialize or reinitialize the circular timer widget safely"""
        try:
            # Always recreate the widget - don't try to reuse deleted widgets
            logger.debug("Initializing circular timer widget...")
            
            # Clean up any existing widget first (it might be deleted already)
            if hasattr(self, 'circular_timer_widget') and self.circular_timer_widget:
                try:
                    # Test if the widget is still valid
                    self.circular_timer_widget.isVisible()
                    logger.debug("Existing widget found, cleaning up...")
                    self.circular_timer_widget.close()
                    self.circular_timer_widget.deleteLater()
                except RuntimeError:
                    # Widget was already deleted
                    logger.debug("Existing widget was already deleted")
                except Exception as e:
                    logger.debug(f"Error cleaning up existing widget: {e}")
                finally:
                    self.circular_timer_widget = None
            
            # Ensure backend is available and reset it
            if not hasattr(self, 'circular_timer_backend') or not self.circular_timer_backend:
                logger.debug("Creating new circular timer backend...")
                self.circular_timer_backend = CircularTimerBackend()
            
            # Reset initialization flag
            self.circular_timer_initialized = False
            
            # Create new widget
            self.circular_timer_widget = QQuickWidget(parent_widget)
            self.circular_timer_widget.setClearColor(Qt.transparent)
            
            # Configure QML widget for transparency
            fmt = QSurfaceFormat()
            fmt.setAlphaBufferSize(8)
            self.circular_timer_widget.setFormat(fmt)
            self.circular_timer_widget.setAttribute(Qt.WA_TranslucentBackground, True)
            self.circular_timer_widget.setAttribute(Qt.WA_NoSystemBackground, True)
            self.circular_timer_widget.setAttribute(Qt.WA_OpaquePaintEvent, False)
            self.circular_timer_widget.setAttribute(Qt.WA_AlwaysStackOnTop, True)
            self.circular_timer_widget.setAttribute(Qt.WA_TranslucentBackground, True)
            self.circular_timer_widget.setResizeMode(QQuickWidget.SizeRootObjectToView)
            
            # Set the timer size and position (center-right area) with enhanced scaling
            base_timer_size = 800
            timer_size = int(base_timer_size * self.scale)
            
            # Calculate responsive positioning based on screen size
            screen_width = self.centralwidget.width()
            screen_height = self.centralwidget.height()
            
            # Position timer responsively - adjust based on screen size
            x_position = int(200 * self.scale)  # Base position from left
            y_position = int(160 * self.scale)  # Base position from top
            
            # For very wide screens, position timer more towards the center-right
            if screen_width >= 3840:
                x_position = int(screen_width * 0.15)  # 15% from left edge
                y_position = int(screen_height * 0.15)  # 15% from top
            elif screen_width >= 2560:
                x_position = int(screen_width * 0.12)  # 12% from left edge  
                y_position = int(screen_height * 0.15)  # 15% from top
                
            self.circular_timer_widget.setGeometry(QtCore.QRect(
                x_position,
                y_position,
                timer_size + int(200 * self.scale),  # Add padding scaled appropriately
                timer_size 
            ))
            
            # Load the CircularTimer QML file
            qml_file_path = os.path.join(os.path.dirname(__file__), 'CircularTimer_enhanced.qml')
            self.circular_timer_widget.setSource(QUrl.fromLocalFile(qml_file_path))
            
            # Set up the backend connection
            root_object = self.circular_timer_widget.rootObject()
            if root_object:
                root_object.setProperty('backend', self.circular_timer_backend)
                # Set initial timer value
                self.circular_timer_backend.set_timer(TimerValue // 1000)
                self.circular_timer_backend.emit_timer_value()
                
                self.circular_timer_initialized = True
                logger.debug(" Circular timer widget initialized successfully")
                return True
            else:
                logger.error(" Failed to get QML root object for circular timer")
                return False
                
        except Exception as e:
            logger.error(f" Error initializing circular timer widget: {e}")
            return False
    
    def reset_circular_timer(self):
        """Reset circular timer state without recreating widget"""
        try:
            if hasattr(self, 'circular_timer_backend') and self.circular_timer_backend:
                # Stop any running countdown
                self.circular_timer_backend.stop_countdown()
                
                # Reset to initial values
                self.circular_timer_backend.set_timer(TimerValue // 1000)
                self.circular_timer_backend.emit_timer_value()
                
                logger.debug(" Circular timer reset successfully")
        except Exception as e:
            logger.error(f" Error resetting circular timer: {e}")
        
    # def play_audio(self):
    #     """Load and play the audio file with safety checks."""
    #     try:
    #         # Ensure player is initialized
    #         if not hasattr(self, 'player') or self.player is None:
    #             logger.warning("Ô∏è  MediaPlayer not initialized, creating new one")
    #             self.player = QMediaPlayer()
            
    #         audio_file = "Assets/mp3/2066.wav"
    #         absolute_path = os.path.abspath(audio_file)
    #         print("Absolute path:", absolute_path)
            
    #         # Check if file exists
    #         if not os.path.exists(absolute_path):
    #             logger.error(f" Audio file not found: {absolute_path}")
    #             return
                
    #         self.player.setMedia(QMediaContent(QtCore.QUrl.fromLocalFile(absolute_path)))
    #         self.player.setVolume(100)
    #         self.player.play()
            
    #         # Safely connect signal (disconnect first to avoid multiple connections)
    #         try:
    #             self.player.mediaStatusChanged.disconnect()
    #         except:
    #             pass  # No existing connection
    #         self.player.mediaStatusChanged.connect(self.check_media_status)
            
    #         logger.debug(" Audio playback started successfully")
            
    #     except Exception as e:
    #         logger.error(f" Error playing audio: {e}")
    
    # def play_audio_2(self):
    #     """Load and play the audio file with safety checks."""
    #     try:
    #         # Ensure player is initialized
    #         if not hasattr(self, 'player') or self.player is None:
    #             logger.warning("Ô∏è  MediaPlayer not initialized, creating new one")
    #             self.player = QMediaPlayer()
            
    #         audio_file = "Assets/mp3/2066.wav"
    #         absolute_path = os.path.abspath(audio_file)
    #         print("Absolute path:", absolute_path)
            
    #         # Check if file exists
    #         if not os.path.exists(absolute_path):
    #             logger.error(f" Audio file not found: {absolute_path}")
    #             return
                
    #         self.player.setMedia(QMediaContent(QtCore.QUrl.fromLocalFile(absolute_path)))
    #         self.player.setVolume(100)
    #         self.player.play()
            
    #         # Safely connect signal (disconnect first to avoid multiple connections)
    #         try:
    #             self.player.mediaStatusChanged.disconnect()
    #         except:
    #             pass  # No existing connection
    #         self.player.mediaStatusChanged.connect(self.check_media_status)
            
    #         logger.debug(" Audio playback started successfully")
            
    #     except Exception as e:
    #         logger.error(f" Error playing audio: {e}")
        
    # def check_media_status(self, status):
    #     """Check media status and stop playback if finished."""
    #     if status == QMediaPlayer.MediaStatus.EndOfMedia:
    #         self.player.stop()
    
    @pyqtSlot(str)
    def on_serial_data_received(self, data):
        """Handle serial data received from device"""
        try:
            logger.debug(f" Serial data received: {data}")
            
            # Process the serial data based on your game logic
            # Example: if data contains score information
             # data expected:
                    # Sc{score}\n
                    # Mstk\n
                    # Ok\n
                    # Crct\n
                    # Miss\n

            global scored, serial_scoring_active, gameStarted
            
            if gameStarted:  # Only update score if game is active
                if data.lower().startswith("sc"):
                    scored = int(data.split("Sc")[1])
                    serial_scoring_active = True
                    logger.info(f"üì• Score updated via serial: +{data} (total: {scored})")
                    
                    # Update the score display if the label exists
                    if hasattr(self, 'label_Score'):
                        self.label_Score.setText(f"Score: {scored}")
                        
                    # BIDIRECTIONAL: Send acknowledgment back
                    # if self.serial_thread:
                    #     self.serial_thread.send_data("ScoreReceived")
                        
                elif data.lower().startswith("mstk"):
                    serial_scoring_active = True
                    logger.info(f"üì• Mstk updated via serial")
                    self.mstk_signal.emit()
                    # BIDIRECTIONAL: Send acknowledgment back
                    # if self.serial_thread:
                    #     self.serial_thread.send_data("MstkReceived")
                        
                elif data.lower().startswith("ok"):
                    serial_scoring_active = True
                    logger.info(f"üì• Ok updated via serial")
                    # self.ok_signal.emit()
                    # BIDIRECTIONAL: Send acknowledgment back
                    # if self.serial_thread:
                    #     self.serial_thread.send_data("OkReceived")
                        
                elif data.lower().startswith("crct"):
                    serial_scoring_active = True
                    logger.info(f"üì• Crct updated via serial")
                    self.crct_signal.emit()
                    # BIDIRECTIONAL: Send acknowledgment back
                    # if self.serial_thread:
                    #     self.serial_thread.send_data("CrctReceived")
                        
                elif data.lower().startswith("miss"):
                    serial_scoring_active = True
                    logger.info(f"üì• Miss updated via serial")
                    # self.miss_signal.emit()
                    # BIDIRECTIONAL: Send acknowledgment back
                    # if self.serial_thread:
                    #     self.serial_thread.send_data("MissReceived")
                        
                else:
                    logger.debug(f"üì• Custom serial data: {data}")
                    # BIDIRECTIONAL: Send acknowledgment for unknown data
                    # if self.serial_thread:
                    #     self.serial_thread.send_data(f"DataReceived:{data}")
                # if data.isdigit():
                #     # Simple numeric data - could be score increment
                    
                #     scored = int(data)
                #     serial_scoring_active = True
                #     logger.info(f" Score updated via serial: +{data} (total: {scored})")
                    
                #     # Update the score display if the label exists
                #     if hasattr(self, 'label_Score'):
                #         self.label_Score.setText(f"Score: {scored}")
                
                # elif data.lower() == "win":
                #     # Game win condition received via serial
                #     global gamefinished
                #     gamefinished = True
                #     serial_scoring_active = True
                #     logger.info(" Win condition received via serial")
                    
                # elif data.lower() == "hit" or data.lower() == "point":
                #     # Hit/point detected
                #     scored += 1
                #     serial_scoring_active = True
                #     logger.info(f" Hit detected via serial! Score: {scored}")
                    
                #     # Update the score display
                #     if hasattr(self, 'label_Score'):
                #         self.label_Score.setText(f"Score: {scored}")
                # else:
                #     # Custom data processing - you can extend this based on your needs
                #     logger.debug(f" Custom serial data: {data}")
            else:
                logger.debug(f" Serial data received but game not active: {data}")
                
        except Exception as e:
            logger.error(f" Error processing serial data: {e}")
    
    @pyqtSlot(bool)
    def on_serial_connection_status_changed(self, connected):
        """Handle serial connection status changes"""
        if connected:
            logger.info(" Serial device connected")
        else:
            logger.warning("Ô∏è  Serial device disconnected")
    
    @pyqtSlot(str)
    def on_serial_error(self, error_message):
        """Handle serial communication errors"""
        logger.error(f" Serial error: {error_message}")
        
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        print(MainWindow.geometry().width())

        if MainWindow.geometry().width() > 1920:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_Activeee.png")
            print("1")
            self.scale = 2
        else:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_Activeee.png")
            print("2")
            self.scale = 1
        
        global TimerValue
        try:
            with open("file2.txt", "r") as file:
                lines = file.readlines()
                if lines:
                    TimerValue = int(lines[-1].strip())
        except FileNotFoundError:
            print("file2.txt not found. Using default timer value.")
            TimerValue = 30000

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        
        MainWindow.setCentralWidget(self.centralwidget)

        
        # Load fonts
        self.font_family = self.load_custom_font("Assets/Fonts/GOTHIC.TTF")
        self.font_family_good = self.load_custom_font("Assets/Fonts/good_times_rg.ttf")
        
        # Background
        self.Background = QtWidgets.QLabel(self.centralwidget)
        self.Background.setGeometry(QtCore.QRect(0, 0, 1920*self.scale, 1080*self.scale))
        self.Background.setText("")
        self.Background.setScaledContents(True)
        self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.Background.setPixmap(self.background_pixmap)
       
        

        
        # Team name label (original position - right side)
        self.TeamNameLabel = QtWidgets.QLabel(self.centralwidget)
        self.TeamNameLabel.setGeometry(QtCore.QRect(1089*self.scale, 378*self.scale, 557*self.scale, 122*self.scale))
        global teamName
        self.TeamNameLabel.setText(teamName)
        self.TeamNameLabel.setAlignment(QtCore.Qt.AlignCenter)
        font = QtGui.QFont()
        font.setPointSize(27*self.scale)
        font.setFamily(self.font_family_good)
        self.TeamNameLabel.setFont(font)
        self.TeamNameLabel.setStyleSheet("color: rgb(255,255,255);")
        
        
        
        # Score label
        self.label_Score = QtWidgets.QLabel(self.centralwidget)
        self.label_Score.setGeometry(QtCore.QRect(1173*self.scale, 622*self.scale, 390*self.scale, 122*self.scale))
        self.label_Score.setAlignment(QtCore.Qt.AlignCenter)
        self.label_Score.setText("Score: "+str(scored))
        font = QtGui.QFont()
        font.setPointSize(25*self.scale)
        font.setFamily(self.font_family_good)
        self.label_Score.setFont(font)
        self.label_Score.setStyleSheet("color: rgb(255,255,255);")
        

        # # label for indicator of serial connection and 
        # self.label_serial_connection = QtWidgets.QLabel(self.centralwidget)
        # self.label_serial_connection.setGeometry(QtCore.QRect(1089*self.scale, 378*self.scale, 557*self.scale, 122*self.scale))
        # self.label_serial_connection.setAlignment(QtCore.Qt.AlignCenter)
        # self.label_serial_connection.setText("Serial Connection: ")
        # font = QtGui.QFont()
        # font.setPointSize(30*self.scale)
        # font.setFamily(self.font_family_good)
        # self.label_serial_connection.setFont(font)
        # self.label_serial_connection.setStyleSheet("color: rgb(255,255,255);")

        # if self.serial_thread.connected:
        #     self.label_serial_connection.setText("Serial Connection: Connected")
        # else:
        #     self.label_serial_connection.setText("Serial Connection: Disconnected")

        # Timer label (replacing LCD)
        # self.label_timer = QtWidgets.QLabel(self.centralwidget)
        # self.label_timer.setGeometry(QtCore.QRect(708*self.scale, 770*self.scale, 503*self.scale, 158*self.scale))
        # self.label_timer.setAlignment(QtCore.Qt.AlignCenter)
        # self.label_timer.setText("00:00")
        # font_timer = QtGui.QFont()
        # font_timer.setPointSize(50*self.scale)
        # font_timer.setFamily(self.font_family_good)
        # self.label_timer.setFont(font_timer)
        # self.label_timer.setStyleSheet("color: rgb(255,255,255);")
        
        # self.set_timer_text(TimerValue//1000)
        
        # Initialize circular timer widget
        try:
            if self.init_circular_timer_widget(self.centralwidget):
                logger.info(" Circular timer widget successfully initialized")
                # Show the circular timer widget
                self.circular_timer_widget.show()
            else:
                logger.warning("Ô∏è  Failed to initialize circular timer widget")
        except Exception as e:
            logger.error(f" Error setting up circular timer widget: {e}")
        
        
        
        
        # Game timer
        self.TimerGame = QTimer(MainWindow)
        self.TimerGame.setSingleShot(True)
        self.TimerGame.setTimerType(QtCore.Qt.PreciseTimer)
        self.TimerGame.timeout.connect(self.stop_game)
       
        self.timer = QtCore.QTimer(MainWindow)
        self.timer.setTimerType(QtCore.Qt.PreciseTimer)
        self.timer.timeout.connect(self.update_timer)
        self.countdown_time = TimerValue//1000

        # Raise elements to proper layer order
        self.Background.setObjectName("Background")
        self.Background.raise_()
        self.TeamNameLabel.raise_()
        self.label_Score.raise_()
        # self.label_timer.raise_()
        
        
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
    
    # def set_timer_text(self, value):
    #     """Set the timer text to the given value in MM:SS format"""
    #     minutes = value // 60
    #     seconds = value % 60
    #     timer_text = f"{minutes:02d}:{seconds:02d}"
    #     self.label_timer.setText(timer_text)
        
    def update_timer(self):
        global RemainingTime
        # if self.serial_thread.connected:
        #     self.label_serial_connection.setText("Serial Connection: Connected")
        # else:
        #     self.label_serial_connection.setText("Serial Connection: Disconnected")
        
        self.countdown_time -= 1
        if gamefinished == True:
            global scored, serial_scoring_active
            
            # No bonuses applied regardless of serial communication status
            if serial_scoring_active:
                print(f"Game finished! Final Score: {scored} (serial score)")
            else:
                print(f"Game finished! Final Score: {scored} (no bonuses applied)")
            
            self.stop_game()
        
        if self.countdown_time == 0:
            self.timer.stop()
            # self.set_timer_text(0)
            # Change timer color to red when time's up
            # self.label_timer.setStyleSheet("color: rgb(244,28,23);")
        
        # Update score display
        self.label_Score.setText("Score: "+str(scored))
        
        # BIDIRECTIONAL: Send score updates via serial
        # if hasattr(self, 'serial_thread') and self.serial_thread and hasattr(self, 'last_sent_score'):
        #     if not hasattr(self, 'last_sent_score') or self.last_sent_score != scored:
        #         if self.serial_thread.send_score_update(scored):
        #             logger.debug(f"üì§ Sent score update: {scored}")
        #             self.last_sent_score = scored
        # elif not hasattr(self, 'last_sent_score'):
        #     self.last_sent_score = scored
        
        RemainingTime = self.countdown_time
        # self.set_timer_text(self.countdown_time)
        
        # Update circular timer backend with current countdown value
        try:
            if hasattr(self, 'circular_timer_backend') and self.circular_timer_backend and self.circular_timer_initialized:
                self.circular_timer_backend.update_countdown_value(self.countdown_time)
        except Exception as e:
            logger.error(f" Error updating circular timer: {e}")
    
    @pyqtSlot()
    def start_game(self):
        global gameStarted, firstDetected
        gameStarted = True
        
        # Start serial monitoring if available
        if self.serial_thread:
            self.serial_thread.start_monitoring()
            
            logger.info(" Serial monitoring started for game")
        
        # Start circular timer
        try:
            if hasattr(self, 'circular_timer_backend') and self.circular_timer_backend and self.circular_timer_initialized:
                self.circular_timer_backend.start_countdown()
                logger.debug(" Circular timer started")
        except Exception as e:
            logger.error(f" Error starting circular timer: {e}")
        
        self.timer.start(1000)
        self.TimerGame.start(TimerValue)
        print("start")
        # self.play_audio()

    @pyqtSlot()
    def stop_game(self):
        global teamName, scored, gameStarted, firstDetected, gamefinished, serial_scoring_active
        
        # Cancel any existing deactivate timer first to prevent multiple timers
        if hasattr(self, 'deactivate_timer') and self.deactivate_timer:
            self.deactivate_timer.stop()
            self.deactivate_timer = None
        
        # Stop serial monitoring if available
        if self.serial_thread:
            self.serial_thread.stop_monitoring()
            logger.info(" Serial monitoring stopped for game")
        
        # Stop circular timer
        try:
            if hasattr(self, 'circular_timer_backend') and self.circular_timer_backend and self.circular_timer_initialized:
                self.circular_timer_backend.stop_countdown()
                logger.debug(" Circular timer stopped")
        except Exception as e:
            logger.error(f" Error stopping circular timer: {e}")
        
        self.label_Score.setText("Score: "+str(scored))
        self.TimerGame.stop()
        self.timer.stop()
        self.save_final_score_to_csv(teamName, scored)

        # self.play_audio_2()
        gameStarted = False
        firstDetected = False
        gamefinished = False
        
        # Emit deactivate signal directly after 5 seconds to trigger score submission
        def emit_deactivate_signal():
            if self.mqtt_thread and hasattr(self.mqtt_thread, 'deactivate_signal'):
                self.mqtt_thread.deactivate_signal.emit()
                print("deactivate signal emitted")
            else:
                print("mqtt_thread is None, deactivate signal not emitted")
            # Clear the timer reference after execution
            self.deactivate_timer = None
        
        # Store timer reference so it can be cancelled during cleanup
        self.deactivate_timer = QtCore.QTimer()
        self.deactivate_timer.setSingleShot(True)
        self.deactivate_timer.timeout.connect(emit_deactivate_signal)
        self.deactivate_timer.start(5000)
        
        # # Deactivate after 5 seconds
        # QtCore.QTimer.singleShot(5000, lambda: (
        #     self.mqtt_thread.client.publish("FastReaction/game/Deactivate", 1),
        #     print("deactivate")
        # ))
        
        print("stop")
    
    def save_final_score_to_csv(self, team_name, final_score):
        """Save final score to CSV file"""
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        csv_file_path = "Fast_Reaction.csv"
        
        try:
            with open(csv_file_path, mode='a', newline='') as file:
                writer = csv.writer(file)
                writer.writerow([team_name, final_score, current_time])
            print("Score saved successfully.")
        except Exception as e:
            print(f"An error occurred while saving the score to CSV: {e}")
    
    @pyqtSlot()
    def restart_game(self):
        # Reset circular timer
        try:
            if hasattr(self, 'circular_timer_backend') and self.circular_timer_backend:
                self.reset_circular_timer()
                logger.debug(" Circular timer reset for restart")
        except Exception as e:
            logger.error(f" Error resetting circular timer for restart: {e}")
        
        self.TimerGame.start(TimerValue)
        print("restart")
        
        self.TimerGame.stop()
        
    def load_custom_font(self, font_path):
        font_id = QtGui.QFontDatabase.addApplicationFont(font_path)
        if font_id == -1:
            print(f"Failed to load font: {font_path}")
            return "Default"
        font_families = QtGui.QFontDatabase.applicationFontFamilies(font_id)
        if font_families:
            return font_families[0]
        return "Default"

    def closeEvent(self, event):
        print("close in active screen")
        logger.info(" Active screen closing...")
        
        # Stop and cleanup circular timer widget
        try:
            if hasattr(self, 'circular_timer_backend') and self.circular_timer_backend:
                self.circular_timer_backend.stop_countdown()
                self.circular_timer_backend = None
                logger.debug(" Circular timer backend cleaned up")
            
            if hasattr(self, 'circular_timer_widget') and self.circular_timer_widget:
                try:
                    self.circular_timer_widget.close()
                    self.circular_timer_widget.deleteLater()
                except RuntimeError:
                    # Widget was already deleted
                    pass
                self.circular_timer_widget = None
                logger.debug(" Circular timer widget cleaned up")
            
            self.circular_timer_initialized = False
        except Exception as e:
            logger.warning(f"Ô∏è  Error cleaning up circular timer: {e}")
        
        # # Stop and cleanup media player
        # if hasattr(self, 'player') and self.player:
        #     try:
        #         self.player.stop()
        #         self.player.setMedia(QMediaContent())  # Clear media
        #         # Disconnect all signals
        #         try:
        #             self.player.mediaStatusChanged.disconnect()
        #         except:
        #             pass
        #         self.player = None
        #         logger.debug(" Media player cleaned up")
        #     except Exception as e:
        #         logger.warning(f"Ô∏è  Error stopping media player: {e}")
        
        
        # Stop and cleanup MQTT thread
        if hasattr(self, 'mqtt_thread') and self.mqtt_thread:
            try:
                # Disconnect all signals first
                try:
                    self.mqtt_thread.start_signal.disconnect()
                    self.mqtt_thread.stop_signal.disconnect()
                    self.mqtt_thread.restart_signal.disconnect()
                    if hasattr(self.mqtt_thread, 'deactivate_signal'):
                        self.mqtt_thread.deactivate_signal.disconnect()
                    if hasattr(self.mqtt_thread, 'activate_signal'):
                        self.mqtt_thread.activate_signal.disconnect()
                    if hasattr(self.mqtt_thread, 'message_signal'):
                        self.mqtt_thread.message_signal.disconnect()
                except:
                    pass
                
                # Stop the thread gracefully using the new stop() method
                self.mqtt_thread.stop()
                self.mqtt_thread = None
                logger.debug(" MQTT thread cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping MQTT thread: {e}")
        
        # Disconnect serial signals (but don't stop the thread - it's managed by MainApp)
        if hasattr(self, 'serial_thread') and self.serial_thread:
            try:
                # Disconnect signals only
                try:
                    self.serial_thread.data_received.disconnect(self.on_serial_data_received)
                    self.serial_thread.connection_status_changed.disconnect(self.on_serial_connection_status_changed)
                    self.serial_thread.error_occurred.disconnect(self.on_serial_error)
                    logger.debug(" Serial signals disconnected")
                except:
                    pass
                # Don't set to None or stop - it's managed by MainApp
            except Exception as e:
                logger.warning(f"Ô∏è  Error disconnecting Serial signals: {e}")
        
        # Disconnect audio signals (they are managed by MainApp and need proper cleanup)
        try:
            # These signals are connected in MainApp.start_Active_screen() and need to be cleaned up
            if hasattr(self, 'miss_signal'):
                try:
                    self.miss_signal.disconnect()
                    logger.debug(" miss_signal disconnected")
                except:
                    pass
            
            if hasattr(self, 'ok_signal'):
                try:
                    self.ok_signal.disconnect()
                    logger.debug(" ok_signal disconnected")
                except:
                    pass
            
            if hasattr(self, 'crct_signal'):
                try:
                    self.crct_signal.disconnect()
                    logger.debug(" crct_signal disconnected")
                except:
                    pass
            
            if hasattr(self, 'mstk_signal'):
                try:
                    self.mstk_signal.disconnect()
                    logger.debug(" mstk_signal disconnected")
                except:
                    pass
                    
            logger.debug(" Audio signals cleaned up")
        except Exception as e:
            logger.warning(f"Ô∏è  Error disconnecting audio signals: {e}")
        
        # Reset global game state
        global gameStarted
        gameStarted = False
        

        
        # Safely stop timers
        if hasattr(self, 'timer') and self.timer:
            try:
                self.timer.stop()
                self.timer = None
                logger.debug(" Timer cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping timer: {e}")
        
        if hasattr(self, 'TimerGame') and self.TimerGame:
            try:
                self.TimerGame.stop()
                self.TimerGame = None
                logger.debug(" Game timer cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping game timer: {e}")
        
        # Clean up deactivate timer
        if hasattr(self, 'deactivate_timer') and self.deactivate_timer:
            try:
                self.deactivate_timer.stop()
                self.deactivate_timer = None
                logger.debug(" Deactivate timer cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping deactivate timer: {e}")
        
        # Safely clear UI widgets
        if hasattr(self, 'Background') and self.Background:
            try:
                self.Background.clear()
                self.Background = None
                logger.debug(" Background cleared")
            except Exception as e:
                logger.warning(f"Ô∏è  Error clearing background: {e}")
        
        
        
        # if hasattr(self, 'label_timer') and self.label_timer:
        #     try:
        #         self.label_timer.hide()
        #         self.label_timer.deleteLater()
        #         self.label_timer = None
        #         logger.debug(" Timer label cleaned up")
        #     except Exception as e:
        #         logger.warning(f"Ô∏è  Error cleaning label_timer: {e}")
        
       
        
        
        # Clean up any other widgets
        if hasattr(self, 'centralwidget') and self.centralwidget:
            try:
                # Clean up all child widgets
                for child in self.centralwidget.findChildren(QtCore.QObject):
                    child.deleteLater()
                self.centralwidget = None
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning central widget: {e}")
        
        event.accept()
        logger.info(" Active screen closed successfully with complete cleanup")
        super().closeEvent(event)


class TeamMember_screen(QtWidgets.QMainWindow):
    """Complete TeamMember Screen implementation"""
    
    def load_custom_font(self, font_path):
        font_id = QtGui.QFontDatabase.addApplicationFont(font_path)
        if font_id == -1:
            print(f"Failed to load font: {font_path}")
            return "Default"
        font_families = QtGui.QFontDatabase.applicationFontFamilies(font_id)
        if font_families:
            return font_families[0]
        return "Default"

    # def play_audio(self):
    #     """Load and play the audio file."""
    #     audio_file = "Assets/mp3/2066.wav"
    #     absolute_path = os.path.abspath(audio_file)
    #     print("Absolute path:", absolute_path)
    #     self.player.setMedia(QMediaContent(QtCore.QUrl.fromLocalFile(absolute_path)))
    #     self.player.setVolume(100)
    #     self.player.play()
    #     self.player.mediaStatusChanged.connect(self.check_media_status)
    
    # def check_media_status(self, status):
    #     """Check media status and stop playback if finished."""
    #     if status == QMediaPlayer.MediaStatus.EndOfMedia:
    #         self.player.stop()
        
    def setupUi(self, Home):
        Home.setObjectName("Home")
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        Home.setLayoutDirection(QtCore.Qt.LeftToRight)
        Home.setAutoFillBackground(False)
        # self.player = QMediaPlayer()

        self.centralwidget = QtWidgets.QWidget(Home)
        self.centralwidget.setFocusPolicy(QtCore.Qt.StrongFocus)
        print(Home.geometry().width())
        self.font_family = self.load_custom_font("Assets/Fonts/GOTHIC.TTF")
        self.font_family_good = self.load_custom_font("Assets/Fonts/good_times_rg.ttf")
        
        if Home.geometry().width() > 1920:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_TeamMembers.png")
            self.scale = 2
            global scaled
            scaled = 2
        else:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_TeamMembers.png")
            self.scale = 1  
            scaled = 1
        
        self.Background = QtWidgets.QLabel(self.centralwidget)
        self.Background.setScaledContents(True)
        self.Background.setGeometry(0, 0, Home.geometry().width(), Home.geometry().height())
        self.Background.setText("")
        self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.Background.setPixmap(self.background_pixmap)
        self.Background.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        
        #label 
        self.Label_team_name = QtWidgets.QLabel(self.centralwidget)
        self.Label_team_name.setGeometry(QtCore.QRect(558*self.scale, 245*self.scale, 802*self.scale, 62*self.scale))
        global teamName
        self.Label_team_name.setText(teamName)
        self.Label_team_name.setAlignment(QtCore.Qt.AlignCenter)
        font_team = QtGui.QFont()
        font_team.setPointSize(40*self.scale)
        font_team.setFamily(self.font_family_good)
        self.Label_team_name.setFont(font_team)
        self.Label_team_name.setStyleSheet("color: rgb(255, 255, 255);")
        # self.Label_team_name.hide()
        self.Label_team_name.raise_()

        # Create team member display table
        self.frame_2 = QtWidgets.QFrame(self.centralwidget)
        self.frame_2.setGeometry(QtCore.QRect(558*self.scale, 327*self.scale, 802*self.scale, 595*self.scale))
        self.gridLayout = QtWidgets.QGridLayout(self.frame_2)
        self.LeaderboardTable = QtWidgets.QTableWidget(self.frame_2)
        self.LeaderboardTable.setRowCount(4)
        self.LeaderboardTable.setColumnCount(1)
        
        # Set up table properties
        font = QtGui.QFont()
        font.setFamily(self.font_family_good)
        font.setPointSize(22*self.scale)
        font.setBold(False)
        font.setItalic(False)
        self.LeaderboardTable.setFont(font)
        self.LeaderboardTable.setFocusPolicy(QtCore.Qt.NoFocus)
        self.LeaderboardTable.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.LeaderboardTable.setAutoFillBackground(False)
        self.LeaderboardTable.setLineWidth(0)
        self.LeaderboardTable.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.LeaderboardTable.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.LeaderboardTable.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.LeaderboardTable.setAutoScroll(False)
        self.LeaderboardTable.setAutoScrollMargin(0)
        self.LeaderboardTable.setProperty("showDropIndicator", False)
        self.LeaderboardTable.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.LeaderboardTable.setTextElideMode(QtCore.Qt.ElideLeft)
        self.LeaderboardTable.setShowGrid(False)
        self.LeaderboardTable.setGridStyle(QtCore.Qt.NoPen)
        self.LeaderboardTable.setWordWrap(True)
        self.LeaderboardTable.setCornerButtonEnabled(True)
        self.LeaderboardTable.setObjectName("LeaderboardTable")
        
        # Custom palette configuration for LeaderboardTable
        palette = QtGui.QPalette()
        
        # Define color scheme
        white_text = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        white_text.setStyle(QtCore.Qt.SolidPattern)
        transparent_bg = QtGui.QBrush(QtGui.QColor(0, 0, 0, 0))
        transparent_bg.setStyle(QtCore.Qt.SolidPattern)
        light_blue = QtGui.QBrush(QtGui.QColor(102, 171, 255))
        light_blue.setStyle(QtCore.Qt.SolidPattern)
        mid_blue = QtGui.QBrush(QtGui.QColor(65, 142, 235))
        mid_blue.setStyle(QtCore.Qt.SolidPattern)
        dark_blue = QtGui.QBrush(QtGui.QColor(14, 57, 108))
        dark_blue.setStyle(QtCore.Qt.SolidPattern)
        medium_blue = QtGui.QBrush(QtGui.QColor(19, 75, 144))
        medium_blue.setStyle(QtCore.Qt.SolidPattern)
        no_brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        no_brush.setStyle(QtCore.Qt.NoBrush)
        black_shadow = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        black_shadow.setStyle(QtCore.Qt.SolidPattern)
        alt_blue = QtGui.QBrush(QtGui.QColor(141, 184, 235))
        alt_blue.setStyle(QtCore.Qt.SolidPattern)
        tooltip_bg = QtGui.QBrush(QtGui.QColor(255, 255, 220))
        tooltip_bg.setStyle(QtCore.Qt.SolidPattern)
        disabled_alt_blue = QtGui.QBrush(QtGui.QColor(28, 113, 216))
        disabled_alt_blue.setStyle(QtCore.Qt.SolidPattern)
        
        # Apply styling to all states
        for state in [QtGui.QPalette.Active, QtGui.QPalette.Inactive, QtGui.QPalette.Disabled]:
            palette.setBrush(state, QtGui.QPalette.WindowText, white_text)
            palette.setBrush(state, QtGui.QPalette.Button, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.Light, light_blue)
            palette.setBrush(state, QtGui.QPalette.Midlight, mid_blue)
            palette.setBrush(state, QtGui.QPalette.Dark, dark_blue)
            palette.setBrush(state, QtGui.QPalette.Mid, medium_blue)
            palette.setBrush(state, QtGui.QPalette.Text, white_text)
            palette.setBrush(state, QtGui.QPalette.BrightText, white_text)
            palette.setBrush(state, QtGui.QPalette.ButtonText, white_text)
            palette.setBrush(state, QtGui.QPalette.Base, no_brush)
            palette.setBrush(state, QtGui.QPalette.Window, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.Shadow, black_shadow)
            palette.setBrush(state, QtGui.QPalette.Highlight, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.HighlightedText, white_text)
            palette.setBrush(state, QtGui.QPalette.ToolTipBase, tooltip_bg)
            palette.setBrush(state, QtGui.QPalette.ToolTipText, black_shadow)
            palette.setBrush(state, QtGui.QPalette.PlaceholderText, white_text)
            
            if state == QtGui.QPalette.Disabled:
                palette.setBrush(state, QtGui.QPalette.AlternateBase, disabled_alt_blue)
            else:
                palette.setBrush(state, QtGui.QPalette.AlternateBase, alt_blue)
        
        self.LeaderboardTable.setPalette(palette)
        
        # Gradient palette styling to match the provided image (consistent with Final_Screen)
        self.LeaderboardTable.setStyleSheet("""
            /* QTableWidget Styling - Gradient Blue Palette */
            QTableWidget {
                background: transparent;
                color: #ffffff;  /* White text color */
                gridline-color: rgba(255, 255, 255, 100);  /* Semi-transparent white gridlines */
                selection-background-color: rgba(255, 255, 255, 50);  /* Light selection */
                selection-color: #ffffff;  /* White selection text */
                border: none;  /* No border */
                border-radius: 10px;  /* Rounded corners */
                padding: 8px;
                margin: 4px;
            }

            QHeaderView::section { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 140),      /* #142849 with 55% transparency for headers */
                    stop:0.5 rgba(107, 53, 39, 140),   /* #6b3527 with 55% transparency */
                    stop:1 rgba(181, 102, 59, 140));   /* #b5663b with 55% transparency */
                color: #ffffff;  /* White text color for header sections */
                padding: 12px;  /* Increased padding for header sections */
                border: none;  /* No border */
                border-radius: 5px;  /* Rounded header corners */
                font-weight: bold;  /* Bold font for headers */
                font-family: """ + self.font_family_good + """;  /* Same font as table */
                font-size: """ + str(int(26*self.scale)) + """px;  /* Larger font size */
                margin: 2px;
            }

            QHeaderView {
                background-color: transparent;  /* Transparent background */
                border: none;
            }

            QTableCornerButton::section {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 140),      /* #142849 with 55% transparency */
                    stop:0.5 rgba(107, 53, 39, 140),   /* #6b3527 with 55% transparency */
                    stop:1 rgba(181, 102, 59, 140));   /* #b5663b with 55% transparency */
                border: none;  /* No border */
                border-radius: 5px;
            }

            QTableWidget::item {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 102),      /* #142849 with 40% transparency */
                    stop:0.5 rgba(107, 53, 39, 102),   /* #6b3527 with 40% transparency */
                    stop:1 rgba(181, 102, 59, 102));   /* #b5663b with 40% transparency */
                padding: 8px;  /* More padding for items */
                border: none;  /* No border for items */
                color: #ffffff;  /* White text color */
                background: rgba(255, 255, 255, 20);  /* Very subtle background */
                margin: 1px;
                border-radius: 3px;
            }

            QTableWidget::item:selected {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 100),
                    stop:1 rgba(20, 40, 73, 150));     /* #142849 for selected */
                color: #ffffff;  /* White text for selected items */
                border: none;  /* No border */
            }

            QTableWidget::item:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 80),
                    stop:1 rgba(107, 53, 39, 150));    /* #6b3527 for hover */
                color: #ffffff;  /* White text on hover */
                border: none;  /* No border */
            }

            QTableWidget::item:focus {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 120),
                    stop:1 rgba(181, 102, 59, 180));   /* #b5663b for focus */
                color: #ffffff;  /* White text on focus */
                border: none;  /* No border */
            }
        """)
        
        # Create table items
        for i in range(4):
            for j in range(1):
                item = QtWidgets.QTableWidgetItem()
                if j == 0:
                    item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                else:
                    item.setTextAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
                self.LeaderboardTable.setItem(i, j, item)

        # Set horizontal headers (TeamMember screen has 1 column)
        self.LeaderboardTable.setHorizontalHeaderLabels(["Team Member"])
        self.LeaderboardTable.horizontalHeader().setVisible(True)
        self.LeaderboardTable.horizontalHeader().setCascadingSectionResizes(False)
        
        # Calculate column width for the table width (802px) - single column takes full width
        # Account for table padding (8px), margin (4px), and border (2px) on each side
        # Total padding: (8+4+2) * 2 = 28px, plus some extra buffer for internal spacing
        available_width = int(802 * self.scale - 50)  # More conservative padding calculation
        team_member_column_width = available_width  # Full width for single column
        
        # Set the column to use the calculated width with stretch
        from PyQt5.QtWidgets import QHeaderView
        self.LeaderboardTable.horizontalHeader().resizeSection(0, team_member_column_width)
        self.LeaderboardTable.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.LeaderboardTable.verticalHeader().setVisible(False)
        self.LeaderboardTable.verticalHeader().setCascadingSectionResizes(False)
        
        # Calculate row heights for the table height (595px)
        # Total available height: 595px minus header and padding
        available_height = int(595 * self.scale - 100)  # Account for header and padding
        row_height = int(available_height / 4)  # Distribute equally among 5 rows
        
        for i in range(4):
            self.LeaderboardTable.verticalHeader().resizeSection(i, row_height)
        self.LeaderboardTable.verticalHeader().setStretchLastSection(True)
        
        self.gridLayout.addWidget(self.LeaderboardTable, 0, 0, 1, 1)

        self.LeaderboardTable.update()
        Home.setCentralWidget(self.centralwidget)
        
        
        self.retranslateUi(Home)
        # self.play_audio()
        self.UpdateTable()
        
        QtCore.QMetaObject.connectSlotsByName(Home)
    
    def retranslateUi(self, Home):
        _translate = QtCore.QCoreApplication.translate
        Home.setWindowTitle(_translate("Home", "MainWindow"))
        self.LeaderboardTable.setSortingEnabled(True)
        item = self.LeaderboardTable.horizontalHeaderItem(0)
        item.setText(_translate("Home", "Team"))
        
        # Set default data for team members
        __sortingEnabled = self.LeaderboardTable.isSortingEnabled()
        self.LeaderboardTable.setSortingEnabled(False)
        global list_players_name
        for i, player_name in enumerate(list_players_name[:4]):
            if i < 5:
                item = self.LeaderboardTable.item(i, 0)
                item.setText(_translate("Home", player_name))
        self.LeaderboardTable.setSortingEnabled(__sortingEnabled)
    
    def showTable(self):
        try:
            if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable:
                self.LeaderboardTable.show()
                self.UpdateTable()
        except (RuntimeError, AttributeError):
            logger.debug("LeaderboardTable already deleted, skipping show()")
        
    def hideTable(self):
        try:
            if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable:
                self.LeaderboardTable.hide()
        except (RuntimeError, AttributeError):
            logger.debug("LeaderboardTable already deleted, skipping hide()")
    
    def UpdateTable(self):
        """Update table with team member names"""
        global teamName
        self.Label_team_name.setText(teamName)
        self.Label_team_name.show()
        global list_players_name
        for i, player_name in enumerate(list_players_name[:4]):
            if i < 5:
                team_item = QtWidgets.QTableWidgetItem(player_name)
                team_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.LeaderboardTable.setItem(i, 0, team_item)
    
    def closeEvent(self, event):
        logger.info(" TeamMember screen closing...")
        
        # Stop and cleanup timers
        if hasattr(self, 'timer') and self.timer:
            try:
                self.timer.stop()
                try:
                    self.timer.timeout.disconnect()
                except:
                    pass
                self.timer = None
                logger.debug(" Timer cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping timer: {e}")
        
        
        # Stop media player
        # if hasattr(self, 'player') and self.player:
        #     try:
        #         self.player.stop()
        #         self.player.setMedia(QMediaContent())
        #         try:
        #             self.player.mediaStatusChanged.disconnect()
        #         except:
        #             pass
        #         self.player = None
        #         logger.debug(" Media player cleaned up")
        #     except Exception as e:
        #         logger.warning(f"Ô∏è  Error stopping media player: {e}")
        
        # Clean up table widget
        if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable:
            try:
                self.LeaderboardTable.hide()
                self.LeaderboardTable.clear()
                self.LeaderboardTable.close()
                self.LeaderboardTable.deleteLater()
                self.LeaderboardTable = None
                logger.debug(" Table widget cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning table widget: {e}")
        
        # Clean up background
        if hasattr(self, 'Background') and self.Background:
            try:
                self.Background.clear()
                self.Background.setPixmap(QPixmap())
                self.Background.deleteLater()
                self.Background = None
                logger.debug(" Background cleared")
            except Exception as e:
                logger.warning(f"Ô∏è  Error clearing background: {e}")
        
        # Clean up layout
        if hasattr(self, 'gridLayout') and self.gridLayout:
            try:
                while self.gridLayout.count():
                    child = self.gridLayout.takeAt(0)
                    if child.widget():
                        child.widget().deleteLater()
                self.gridLayout = None
                logger.debug(" Grid layout cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning grid layout: {e}")
        
        # Clean up central widget
        if hasattr(self, 'centralwidget') and self.centralwidget:
            try:
                for child in self.centralwidget.findChildren(QtCore.QObject):
                    child.deleteLater()
                self.centralwidget.deleteLater()
                self.centralwidget = None
                logger.debug(" Central widget cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning central widget: {e}")
        
        event.accept()
        logger.info(" TeamMember screen closed successfully with complete cleanup")
        super().closeEvent(event)


class Home_screen(QtWidgets.QMainWindow):
    """Complete Home Screen implementation"""
    
    def load_custom_font(self, font_path):
        font_id = QtGui.QFontDatabase.addApplicationFont(font_path)
        if font_id == -1:
            print(f"Failed to load font: {font_path}")
            return "Default"
        font_families = QtGui.QFontDatabase.applicationFontFamilies(font_id)
        if font_families:
            return font_families[0]
        return "Default"

    # def play_audio(self):
    #     """Load and play the audio file."""
    #     audio_file = "Assets/mp3/2066.wav"
    #     absolute_path = os.path.abspath(audio_file)
    #     print("Absolute path:", absolute_path)
    #     self.player.setMedia(QMediaContent(QtCore.QUrl.fromLocalFile(absolute_path)))
    #     self.player.setVolume(100)
    #     self.player.play()
    #     self.player.mediaStatusChanged.connect(self.check_media_status)
    
    # def check_media_status(self, status):
    #     """Check media status and stop playback if finished."""
    #     if status == QMediaPlayer.MediaStatus.EndOfMedia:
    #         self.player.stop()
        
    def setupUi(self, Home):
        Home.setObjectName("Home")
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        Home.setLayoutDirection(QtCore.Qt.LeftToRight)
        Home.setAutoFillBackground(False)
        # self.player = QMediaPlayer()

        self.centralwidget = QtWidgets.QWidget(Home)
        self.centralwidget.setFocusPolicy(QtCore.Qt.StrongFocus)
        print(Home.geometry().width())
        self.font_family = self.load_custom_font("Assets/Fonts/GOTHIC.TTF")
        self.font_family_good = self.load_custom_font("Assets/Fonts/good_times_rg.ttf")
        
        if Home.geometry().width() > 1920:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_GameName.png")
            self.scale = 2
            global scaled
            scaled = 2
        else:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_GameName.png")
            self.scale = 1  
            scaled = 1
        
        self.Background = QtWidgets.QLabel(self.centralwidget)
        self.Background.setScaledContents(True)
        self.Background.setGeometry(0, 0, Home.geometry().width(), Home.geometry().height())
        self.Background.setText("")
        self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        self.Background.setPixmap(self.background_pixmap)
        self.Background.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        
        # Create leaderboard table
        self.frame_2 = QtWidgets.QFrame(self.centralwidget)
        self.frame_2.setGeometry(QtCore.QRect(560*self.scale, 328*self.scale, 802*self.scale, 595*self.scale))
        self.gridLayout = QtWidgets.QGridLayout(self.frame_2)
        self.LeaderboardTable = QtWidgets.QTableWidget(self.frame_2)
        self.LeaderboardTable.setRowCount(5)
        self.LeaderboardTable.setColumnCount(2)
        

        
        # Set up table properties
        font = QtGui.QFont()
        font.setFamily(self.font_family_good)
        font.setPointSize(22*self.scale)
        font.setBold(False)
        font.setItalic(False)
        self.LeaderboardTable.setFont(font)
        self.LeaderboardTable.setFocusPolicy(QtCore.Qt.NoFocus)
        self.LeaderboardTable.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.LeaderboardTable.setAutoFillBackground(False)
        self.LeaderboardTable.setLineWidth(0)
        self.LeaderboardTable.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.LeaderboardTable.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.LeaderboardTable.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.LeaderboardTable.setAutoScroll(False)
        self.LeaderboardTable.setAutoScrollMargin(0)
        self.LeaderboardTable.setProperty("showDropIndicator", False)
        self.LeaderboardTable.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.LeaderboardTable.setTextElideMode(QtCore.Qt.ElideLeft)
        self.LeaderboardTable.setShowGrid(False)
        self.LeaderboardTable.setGridStyle(QtCore.Qt.NoPen)
        self.LeaderboardTable.setWordWrap(True)
        self.LeaderboardTable.setCornerButtonEnabled(True)
        self.LeaderboardTable.setObjectName("LeaderboardTable")
        
        # Custom palette configuration for LeaderboardTable - consistent across all states
        palette = QtGui.QPalette()
        
        # Define color scheme once
        white_text = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        white_text.setStyle(QtCore.Qt.SolidPattern)
        transparent_bg = QtGui.QBrush(QtGui.QColor(0, 0, 0, 0))
        transparent_bg.setStyle(QtCore.Qt.SolidPattern)
        light_blue = QtGui.QBrush(QtGui.QColor(102, 171, 255))
        light_blue.setStyle(QtCore.Qt.SolidPattern)
        mid_blue = QtGui.QBrush(QtGui.QColor(65, 142, 235))
        mid_blue.setStyle(QtCore.Qt.SolidPattern)
        dark_blue = QtGui.QBrush(QtGui.QColor(14, 57, 108))
        dark_blue.setStyle(QtCore.Qt.SolidPattern)
        medium_blue = QtGui.QBrush(QtGui.QColor(19, 75, 144))
        medium_blue.setStyle(QtCore.Qt.SolidPattern)
        no_brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        no_brush.setStyle(QtCore.Qt.NoBrush)
        black_shadow = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        black_shadow.setStyle(QtCore.Qt.SolidPattern)
        alt_blue = QtGui.QBrush(QtGui.QColor(141, 184, 235))
        alt_blue.setStyle(QtCore.Qt.SolidPattern)
        tooltip_bg = QtGui.QBrush(QtGui.QColor(255, 255, 220))
        tooltip_bg.setStyle(QtCore.Qt.SolidPattern)
        disabled_alt_blue = QtGui.QBrush(QtGui.QColor(28, 113, 216))
        disabled_alt_blue.setStyle(QtCore.Qt.SolidPattern)
        
        # Apply IDENTICAL styling to ALL states (Active, Inactive, Disabled)
        for state in [QtGui.QPalette.Active, QtGui.QPalette.Inactive, QtGui.QPalette.Disabled]:
            palette.setBrush(state, QtGui.QPalette.WindowText, white_text)
            palette.setBrush(state, QtGui.QPalette.Button, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.Light, light_blue)
            palette.setBrush(state, QtGui.QPalette.Midlight, mid_blue)
            palette.setBrush(state, QtGui.QPalette.Dark, dark_blue)
            palette.setBrush(state, QtGui.QPalette.Mid, medium_blue)
            palette.setBrush(state, QtGui.QPalette.Text, white_text)
            palette.setBrush(state, QtGui.QPalette.BrightText, white_text)
            palette.setBrush(state, QtGui.QPalette.ButtonText, white_text)
            palette.setBrush(state, QtGui.QPalette.Base, no_brush)
            palette.setBrush(state, QtGui.QPalette.Window, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.Shadow, black_shadow)
            palette.setBrush(state, QtGui.QPalette.Highlight, transparent_bg)
            palette.setBrush(state, QtGui.QPalette.HighlightedText, white_text)
            palette.setBrush(state, QtGui.QPalette.ToolTipBase, tooltip_bg)
            palette.setBrush(state, QtGui.QPalette.ToolTipText, black_shadow)
            palette.setBrush(state, QtGui.QPalette.PlaceholderText, white_text)
            
            # Use different AlternateBase for disabled state
            if state == QtGui.QPalette.Disabled:
                palette.setBrush(state, QtGui.QPalette.AlternateBase, disabled_alt_blue)
            else:
                palette.setBrush(state, QtGui.QPalette.AlternateBase, alt_blue)
        
        self.LeaderboardTable.setPalette(palette)
        
        # Gradient palette styling to match the provided image (consistent with Final_Screen)
        self.LeaderboardTable.setStyleSheet("""
            /* QTableWidget Styling - Gradient Blue Palette */
            QTableWidget {
                background: transparent;
                color: #ffffff;  /* White text color */
                gridline-color: rgba(255, 255, 255, 100);  /* Semi-transparent white gridlines */
                selection-background-color: rgba(255, 255, 255, 50);  /* Light selection */
                selection-color: #ffffff;  /* White selection text */
                border: none;  /* No border */
                border-radius: 10px;  /* Rounded corners */
                padding: 8px;
                margin: 4px;
            }

            QHeaderView::section { 
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 140),      /* #142849 with 55% transparency for headers */
                    stop:0.5 rgba(107, 53, 39, 140),   /* #6b3527 with 55% transparency */
                    stop:1 rgba(181, 102, 59, 140));   /* #b5663b with 55% transparency */
                color: #ffffff;  /* White text color for header sections */
                padding: 12px;  /* Increased padding for header sections */
                border: none;  /* No border */
                border-radius: 5px;  /* Rounded header corners */
                font-weight: bold;  /* Bold font for headers */
                font-family: """ + self.font_family_good + """;  /* Same font as table */
                font-size: """ + str(int(26*self.scale)) + """px;  /* Larger font size */
                margin: 2px;
            }

            QHeaderView {
                background-color: transparent;  /* Transparent background */
                border: none;
            }

            QTableCornerButton::section {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 140),      /* #142849 with 55% transparency */
                    stop:0.5 rgba(107, 53, 39, 140),   /* #6b3527 with 55% transparency */
                    stop:1 rgba(181, 102, 59, 140));   /* #b5663b with 55% transparency */
                border: none;  /* No border */
                border-radius: 5px;
            }

            QTableWidget::item {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(20, 40, 73, 102),      /* #142849 with 40% transparency */
                    stop:0.5 rgba(107, 53, 39, 102),   /* #6b3527 with 40% transparency */
                    stop:1 rgba(181, 102, 59, 102));   /* #b5663b with 40% transparency */
                padding: 8px;  /* More padding for items */
                border: none;  /* No border for items */
                color: #ffffff;  /* White text color */
                background: rgba(255, 255, 255, 20);  /* Very subtle background */
                margin: 1px;
                border-radius: 3px;
            }

            QTableWidget::item:selected {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 100),
                    stop:1 rgba(20, 40, 73, 150));     /* #142849 for selected */
                color: #ffffff;  /* White text for selected items */
                border: none;  /* No border */
            }

            QTableWidget::item:hover {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 80),
                    stop:1 rgba(107, 53, 39, 150));    /* #6b3527 for hover */
                color: #ffffff;  /* White text on hover */
                border: none;  /* No border */
            }

            QTableWidget::item:focus {
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 rgba(255, 255, 255, 120),
                    stop:1 rgba(181, 102, 59, 180));   /* #b5663b for focus */
                color: #ffffff;  /* White text on focus */
                border: none;  /* No border */
            }
        """)
        
        # Create vertical header items
        item = QtWidgets.QTableWidgetItem()
        self.LeaderboardTable.setVerticalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignVCenter)
        self.LeaderboardTable.setVerticalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.LeaderboardTable.setVerticalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.LeaderboardTable.setVerticalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.LeaderboardTable.setVerticalHeaderItem(4, item)
        
        # Create horizontal header items
        item = QtWidgets.QTableWidgetItem()
        font = QtGui.QFont()
        font.setFamily(self.font_family_good)
        font.setPointSize(20*self.scale)
        item.setFont(font)
        self.LeaderboardTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        font = QtGui.QFont()
        font.setFamily(self.font_family_good)
        font.setPointSize(20*self.scale)
        item.setFont(font)
        self.LeaderboardTable.setHorizontalHeaderItem(1, item)
        
        # Create table items with enhanced properties
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsDropEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsTristate)
        
        # Create all table items
        for i in range(5):
            for j in range(2):
                item = QtWidgets.QTableWidgetItem()
                if j == 0:
                    item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                else:
                    item.setTextAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
                self.LeaderboardTable.setItem(i, j, item)

        

        # Set horizontal headers with custom properties (consistent with Final_Screen)
        self.LeaderboardTable.setHorizontalHeaderLabels(["Team", "Score"])
        self.LeaderboardTable.horizontalHeader().setVisible(True)
        self.LeaderboardTable.horizontalHeader().setCascadingSectionResizes(False)
        
        # Calculate column widths for the table width (802px) - consistent with Final_Screen
        # Account for table padding (8px), margin (4px), and border (2px) on each side
        # Total padding: (8+4+2) * 2 = 28px, plus some extra buffer for internal spacing
        available_width = int(802 * self.scale - 50)  # More conservative padding calculation
        team_column_width = int(available_width * 0.60)    # 60% for team name
        score_column_width = int(available_width * 0.40)   # 40% for score
        
        # Set the first column to a fixed width, let the second column stretch
        self.LeaderboardTable.horizontalHeader().resizeSection(0, team_column_width)
        self.LeaderboardTable.horizontalHeader().setStretchLastSection(True)
        # Alternative: use section resize mode for better control
        from PyQt5.QtWidgets import QHeaderView
        self.LeaderboardTable.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.LeaderboardTable.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
        self.LeaderboardTable.verticalHeader().setVisible(False)
        self.LeaderboardTable.verticalHeader().setCascadingSectionResizes(False)
        
        # Calculate row heights for the table height (595px) - consistent with Final_Screen
        # Total available height: 595px minus header and padding
        available_height = int(595 * self.scale - 100)  # Account for header and padding
        row_height = int(available_height / 5)  # Distribute equally among 5 rows
        
        for i in range(5):
            self.LeaderboardTable.verticalHeader().resizeSection(i, row_height)
        self.LeaderboardTable.verticalHeader().setStretchLastSection(True)
        
        self.gridLayout.addWidget(self.LeaderboardTable, 0, 0, 1, 1)
        self.LeaderboardTable.hide()

        # self.LeaderboardTable.update()
        Home.setCentralWidget(self.centralwidget)
        
        # Timers for showing table and switching to inactive
        self.timer = QTimer(Home)
        self.timer.setTimerType(Qt.PreciseTimer)
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.Inactive)
        self.timer.start(11000)
        
        
       
        
        self.timer3 = QTimer(Home)
        self.timer3.setTimerType(Qt.PreciseTimer)
        self.timer3.timeout.connect(self.looping)
        
        self.retranslateUi(Home)
        # self.play_audio()
        
        QtCore.QMetaObject.connectSlotsByName(Home)
    
    def retranslateUi(self, Home):
        _translate = QtCore.QCoreApplication.translate
        Home.setWindowTitle(_translate("Home", "MainWindow"))
        self.LeaderboardTable.setSortingEnabled(True)
        item = self.LeaderboardTable.horizontalHeaderItem(0)
        item.setText(_translate("Home", "Team"))
        item = self.LeaderboardTable.horizontalHeaderItem(1)
        item.setText(_translate("Home", "Score"))
        
        # Set default data
        __sortingEnabled = self.LeaderboardTable.isSortingEnabled()
        self.LeaderboardTable.setSortingEnabled(False)
        # item = self.LeaderboardTable.item(0, 0)
        # # item.setText(_translate("Home", "Team 1"))
        # item = self.LeaderboardTable.item(0, 1)
        # item.setText(_translate("Home", "5"))
        # item = self.LeaderboardTable.item(1, 0)
        # # item.setText(_translate("Home", "Team 2"))
        # item = self.LeaderboardTable.item(1, 1)
        # item.setText(_translate("Home", "6"))
        # # item = self.LeaderboardTable.item(2, 0)
        # item.setText(_translate("Home", "Team 3"))
        # item = self.LeaderboardTable.item(2, 1)
        # item.setText(_translate("Home", "548"))
        # item = self.LeaderboardTable.item(3, 0)
        # item.setText(_translate("Home", "Team 5"))
        # item = self.LeaderboardTable.item(3, 1)
        # item.setText(_translate("Home", "2"))
        # item = self.LeaderboardTable.item(4, 0)
        # item.setText(_translate("Home", "Team 55"))
        # item = self.LeaderboardTable.item(4, 1)
        # item.setText(_translate("Home", "55"))
        self.LeaderboardTable.setSortingEnabled(__sortingEnabled)
    
    def showTable(self):
        self.LeaderboardTable.show()
        self.UpdateTable()
        
    def hideTable(self):
        self.LeaderboardTable.hide()
    
    def UpdateTable(self):
        global list_top5_FastReaction    
        sorted_data = sorted(list_top5_FastReaction, key=lambda item: item[1], reverse=True)

        for i, (team, score) in enumerate(sorted_data):
            if i >= 5:
                break

            team_item = QtWidgets.QTableWidgetItem(team)
            team_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.LeaderboardTable.setItem(i, 0, team_item)

            score_item = QtWidgets.QTableWidgetItem(str(score))
            score_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.LeaderboardTable.setItem(i, 1, score_item)

    def Inactive(self):
        self.timer.stop()
        self.timer3.start(9000)
        if scaled == 1:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_inActive.png")
        else:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_inActive.png")
        
        try:
            if hasattr(self, 'Background') and self.Background:
                self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.Background.setPixmap(self.background_pixmap)
                logger.debug(" Intro image loaded successfully")
        except (RuntimeError, AttributeError):
            logger.debug("Background widget already deleted, skipping pixmap operations")
        # self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        # self.Background.setPixmap(self.background_pixmap)
        # Safe table show - check if widget still exists
        try:
            if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable:
                self.LeaderboardTable.show()
                self.UpdateTable()
        except (RuntimeError, AttributeError):
            logger.debug("LeaderboardTable already deleted, skipping show()")
        global homeOpened
        homeOpened = True
    
    def looping(self):
        """Enhanced looping function with improved safety (from game2)"""
        logger.debug(" Starting looping cycle")
        
        # Safe timer stop
        try:
            if hasattr(self, 'timer3') and self.timer3:
                self.timer3.stop()
        except (RuntimeError, AttributeError):
            pass

        # Safe table hide - check if widget still exists    
        try:
            if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable:
                self.LeaderboardTable.hide()
        except (RuntimeError, AttributeError):
            logger.debug("LeaderboardTable already deleted, skipping hide()")
            
        # Load intro image with proper scaling
        if scaled == 1:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_GameName.png")
        else:
            self.background_pixmap = QPixmap("Assets/1k/FastReaction_GameName.png")
            
        # Safe background and pixmap operations
        try:
            if hasattr(self, 'Background') and self.Background:
                self.background_pixmap = self.background_pixmap.scaled(self.Background.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.Background.setPixmap(self.background_pixmap)
                logger.debug(" Intro image loaded successfully")
        except (RuntimeError, AttributeError):
            logger.debug("Background widget already deleted, skipping pixmap operations")
            
        # Safe timer restart with proper error handling
        try:
            if hasattr(self, 'timer') and self.timer:
                self.timer.start(11000)
                logger.debug("‚è∞ Timer restarted for 11 seconds")
        except (RuntimeError, AttributeError):
            logger.debug("Timer already deleted, skipping start()")
            
        # Set homeOpened flag for game manager detection
        global homeOpened
        homeOpened = True
        logger.debug(" Looping cycle completed successfully")
    
    def closeEvent(self, event):
        logger.info(" Home screen closing...")
        
        # Stop and cleanup timers
        if hasattr(self, 'timer') and self.timer:
            try:
                self.timer.stop()
                # Disconnect signals
                try:
                    self.timer.timeout.disconnect()
                except:
                    pass
                self.timer = None
                logger.debug(" Timer cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping timer: {e}")
        
        
        
        if hasattr(self, 'timer3') and self.timer3:
            try:
                self.timer3.stop()
                # Disconnect signals
                try:
                    self.timer3.timeout.disconnect()
                except:
                    pass
                self.timer3 = None
                logger.debug(" Timer3 cleaned up")
            except Exception as e:
                logger.warning(f"Ô∏è  Error stopping timer3: {e}")
        
        
        # # Stop media player if it exists
        # if hasattr(self, 'player') and self.player:
        #     try:
        #         self.player.stop()
        #         self.player.setMedia(QMediaContent())
        #         try:
        #             self.player.mediaStatusChanged.disconnect()
        #         except:
        #             pass
        #         self.player = None
        #         logger.debug(" Media player cleaned up")
        #     except Exception as e:
        #         logger.warning(f"Ô∏è  Error stopping media player: {e}")
        
        # Clean up table widget with safe Qt object handling
        try:
            if hasattr(self, 'LeaderboardTable') and self.LeaderboardTable is not None:
                try:
                    self.LeaderboardTable.hide()
                    self.LeaderboardTable.clear()
                    self.LeaderboardTable.close()
                    self.LeaderboardTable.deleteLater()
                    logger.debug(" Table widget cleaned up")
                except (RuntimeError, AttributeError):
                    logger.debug("Table widget already deleted by Qt, skipping cleanup")
                finally:
                    self.LeaderboardTable = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Table widget reference already invalid, skipping cleanup")
            self.LeaderboardTable = None
        
        # Clean up background with safe Qt object handling
        try:
            if hasattr(self, 'Background') and self.Background is not None:
                try:
                    self.Background.clear()
                    self.Background.setPixmap(QPixmap())  # Remove pixmap reference
                    self.Background.deleteLater()
                    logger.debug(" Background cleared")
                except (RuntimeError, AttributeError):
                    logger.debug("Background widget already deleted by Qt, skipping cleanup")
                finally:
                    self.Background = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Background widget reference already invalid, skipping cleanup")
            self.Background = None
        
        # Clean up layout with safe Qt object handling
        try:
            if hasattr(self, 'gridLayout') and self.gridLayout is not None:
                try:
                    # Remove all items from layout
                    while self.gridLayout.count():
                        child = self.gridLayout.takeAt(0)
                        if child.widget():
                            child.widget().deleteLater()
                    logger.debug(" Grid layout cleaned up")
                except (RuntimeError, AttributeError):
                    logger.debug("Grid layout already deleted by Qt, skipping cleanup")
                finally:
                    self.gridLayout = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Grid layout reference already invalid, skipping cleanup")
            self.gridLayout = None
        
        # Clean up central widget and all its children with safe Qt object handling
        try:
            if hasattr(self, 'centralwidget') and self.centralwidget is not None:
                try:
                    # Clean up all child widgets
                    for child in self.centralwidget.findChildren(QtCore.QObject):
                        child.deleteLater()
                    self.centralwidget.deleteLater()
                    logger.debug(" Central widget cleaned up")
                except (RuntimeError, AttributeError):
                    logger.debug("Central widget already deleted by Qt, skipping cleanup")
                finally:
                    self.centralwidget = None
        except (RuntimeError, SystemError, AttributeError):
            logger.debug("Central widget reference already invalid, skipping cleanup")
            self.centralwidget = None
        
        event.accept()
        logger.info(" Home screen closed successfully with complete cleanup")
        super().closeEvent(event)


class MainApp(QtWidgets.QMainWindow):
    """Complete Main Application with all screens and new API integration"""
    
    def __init__(self):
        super().__init__()
        logger.info(" MainApp initializing with complete UI and new API...")
        
        # Initialize Serial thread from config
        self.serial_thread = None
        serial_config = config.settings.serial
        
        if serial_config.enabled:
            try:
                self.serial_thread = SimpleSerialThread(serial_config)
                self.serial_thread.start()
                logger.info(f" Serial thread initialized for port: {serial_config.port}")
                logger.info(f" Serial config: baudrate={serial_config.baudrate}, auto_reconnect={serial_config.auto_reconnect}")
            except Exception as e:
                logger.warning(f"Ô∏è  Failed to initialize serial thread: {e}")
                self.serial_thread = None
        else:
            logger.info(" Serial communication disabled in config")
        
        # Setup mainWindow and screens
        self.sized = QtWidgets.QDesktopWidget().screenGeometry()
        self.ui_final = Final_Screen()
        self.ui_home = Home_screen()
        self.ui_active = Active_screen(serial_thread=self.serial_thread)    
        self.ui_team_member = TeamMember_screen()
        
        self.mainWindow = QtWidgets.QMainWindow()

        self.mainWindow.setObjectName("Home")
        self.mainWindow.setWindowTitle("Fast Reaction Game - Complete")
        self.mainWindow.setFixedSize(self.sized.width(), self.sized.height())
        print(self.sized.width(), self.sized.height())
        self.mainWindow.setWindowFlags(QtCore.Qt.FramelessWindowHint)
        
        # Initialize GameManager with new API
        try:
            self.game_manager = GameManager()
            logger.info(" GameManager initialized with new API")
        except Exception as e:
            logger.error(f" Failed to initialize GameManager: {e}")
            raise
            
        # Connection signals for the game manager with safety checks
        if hasattr(self, 'game_manager') and self.game_manager:
            # 1. init_signal: Triggered when the game manager is initialized
            self.game_manager.init_signal.connect(self.start_TeamMember_screen)
            # 2. start_signal: Triggered when the game manager starts
            self.game_manager.start_signal.connect(lambda: (
                self.start_Active_screen(),
                self._safe_mqtt_subscribe(),
                self.ui_active.start_game() if hasattr(self, 'ui_active') and self.ui_active else None
            ))
            # 3. cancel_signal: Triggered when the game manager is cancelled
            self.game_manager.cancel_signal.connect(self._handle_game_cancellation)
            # 4. submit_signal: Triggered when the game manager is submitted
            self.game_manager.submit_signal.connect(self.start_final_screen)
            logger.debug(" GameManager signals connected successfully")
            
            # Connect deactivate signal to trigger score submission (with enhanced safety checks)
            if (hasattr(self, 'ui_active') and self.ui_active and 
                hasattr(self.ui_active, 'mqtt_thread') and self.ui_active.mqtt_thread and
                hasattr(self.ui_active.mqtt_thread, 'deactivate_signal')):
                try:
                    self.ui_active.mqtt_thread.deactivate_signal.connect(
                        self.game_manager.trigger_score_submission
                    )
                    logger.debug(" Deactivate signal connected to GameManager")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error connecting deactivate signal: {e}")
            else:
                logger.warning("Ô∏è  MQTT thread or deactivate signal not properly initialized")
        else:
            logger.error(" GameManager not available for signal connections")
        # ------------------------------
        audio_files = {
            'continuous': 'Assets/mp3/2066.wav',
            'inactive_game': 'Assets/mp3/game-music-loop-inactive.mp3',
            # correct.mp3
# correct_2.mp3
# miss.mp3
# wrong-answer.mp3
# wrong-answer_2.mp3
            'active_game': 'Assets/mp3/game-music-loop-active.mp3',
            'miss_sound': 'Assets/mp3/miss.mp3',
            'ok_sound': 'Assets/mp3/game-music-loop-active.mp3',
            'crct_sound': 'Assets/mp3/correct.mp3',
            'mstk_sound': 'Assets/mp3/wrong-answer.mp3'
        }
        
        self.audio_thread = AudioServiceThread(audio_files)
        
        # Connect signals
        self.audio_thread.service_ready.connect(lambda: print("Audio service ready!"))
        self.audio_thread.service_error.connect(lambda error: print(f"Audio service error: {error}"))
        self.audio_thread.player_state_changed.connect(
            lambda name, state: print(f"Player {name} state: {state}")
        )

        self.start_Home_screen()


         # Start the thread
        self.audio_thread.start()
        # Test the service
        print("Testing audio service...")
        
        # Test continuous sound
        self.audio_thread.play_inactive_game_sound()

        """
        @comment: keep this for testing the game manager
        """
        # ------------------------------
        # self.start_Active_screen()
        # self.serial_thread.start_monitoring()
        # self.serial_thread.serial_connection.write("Start\n".encode('utf-8'))
        # self.ui_active.start_game()
        # ------------------------------
        # self.start_final_screen()

        # Start game manager after delay 
        QtCore.QTimer.singleShot(5000, self.game_manager.start)
        
        self.mainWindow.showFullScreen()
        logger.info(" MainApp initialization complete")
                
    def start_Home_screen(self):
        logger.info(" Starting Home Screen")
        
        # Force stop all timers before transition
        self._force_stop_all_timers()
        
        # Clean up previous screens
        self._cleanup_previous_screens()
        
        self.audio_thread.stop_continuous_sound()
        self.audio_thread.stop_active_game_sound()
        self.audio_thread.play_inactive_game_sound()

        # Reset global game state
        global list_players_score, list_players_name, scored, serial_scoring_active
        list_players_score = [0,0,0,0,0]
        list_players_name.clear()
        scored = 0
        serial_scoring_active = False
        
        # Initialize home screen with error handling
        if hasattr(self, 'ui_home') and self.ui_home:
            try:
                self.ui_home.setupUi(self.mainWindow)
                logger.info(" Home screen initialized successfully")
                
                # Set homeOpened flag so game manager can detect home screen is ready
                global homeOpened
                homeOpened = True
                logger.info(" Home screen is now ready for game initialization")
                
            except Exception as e:
                logger.error(f" Error setting up home screen: {e}")
                return
        else:
            logger.error(" ui_home not properly initialized")
            return
       
        quit_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence('q'), self.mainWindow)
        quit_shortcut.activated.connect(self.close_application)
        
    def start_TeamMember_screen(self):
        logger.info(" Starting TeamMember Screen")
        
        # Clean up previous screens
        self._cleanup_previous_screens()
        self.audio_thread.stop_continuous_sound()
        self.audio_thread.stop_active_game_sound()
        self.audio_thread.play_inactive_game_sound()
        
        # Initialize team member screen with error handling
        if hasattr(self, 'ui_team_member') and self.ui_team_member:
            try:
                self.ui_team_member.setupUi(self.mainWindow)
                logger.info(" TeamMember screen initialized successfully")
            except Exception as e:
                logger.error(f" Error setting up team member screen: {e}")
                return
        else:
            logger.error(" ui_team_member not properly initialized")
            return
       
        quit_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence('q'), self.mainWindow)
        quit_shortcut.activated.connect(self.close_application)
    
    def _handle_game_cancellation(self):
        """Robust handler for game cancellation that works regardless of current screen state (improved from CAGE)"""
        logger.warning("" + "=" * 50)
        logger.warning(" GAME CANCELLATION DETECTED")
        logger.warning("" + "=" * 50)
        
        try:
            # Safely cleanup active screen components
            if hasattr(self, 'ui_active') and self.ui_active:
                try:
                    if hasattr(self.ui_active, 'TimerGame') and self.ui_active.TimerGame:
                        self.ui_active.TimerGame.stop()
                        logger.debug(" TimerGame stopped")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error stopping TimerGame: {e}")
                
                try:
                    if hasattr(self.ui_active, 'timer') and self.ui_active.timer:
                        self.ui_active.timer.stop()
                        logger.debug(" Timer stopped")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error stopping timer: {e}")
                
                
                try:
                    if hasattr(self.ui_active, 'mqtt_thread') and self.ui_active.mqtt_thread:
                        self.ui_active.mqtt_thread.unsubscribe_from_data_topics()
                        logger.debug(" MQTT unsubscribed")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error unsubscribing MQTT: {e}")
                
                try:
                    # Check if ui_active is still valid before closing
                    try:
                        self.ui_active.objectName()  # Test if object is still valid
                        self.ui_active.close()
                        logger.debug(" Active screen closed")
                    except RuntimeError:
                        logger.debug(" Active screen was already deleted by Qt")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error closing active screen: {e}")
                
                # CRITICAL: Reset the Active_screen state instead of recreating it
                try:
                    logger.info(" Resetting Active_screen state after cancellation...")
                    self._reset_active_screen_state()
                    logger.info(" Active_screen state reset successfully")
                    
                except Exception as e:
                    logger.error(f" Error resetting Active_screen state: {e}")
            
            # Force manual reset of essential flags only
            if hasattr(self, 'game_manager') and self.game_manager:
                self.game_manager.game_result_id = None
                self.game_manager.submit_score_flag = False
                self.game_manager.started_flag = False  # CRITICAL: Reset like CAGE_Game.py
                self.game_manager.cancel_flag = False
                logger.debug(f" GameManager flags reset: started_flag={self.game_manager.started_flag}")
            
        except Exception as e:
            logger.error(f" Error during cancellation cleanup: {e}")
        
        # Always try to go to home screen, regardless of cleanup errors
        try:
            logger.info(" Moving to home screen after cancellation...")
            self.start_Home_screen()
            logger.info(" Successfully moved to home screen after cancellation")
        except Exception as e:
            logger.error(f" Error moving to home screen after cancellation: {e}")
            # Last resort - try basic home screen setup
            try:
                if hasattr(self, 'ui_home') and self.ui_home:
                    self.ui_home.setupUi(self.mainWindow)
                    self.mainWindow.show()
                    logger.info(" Last resort home screen setup successful")
            except Exception as last_resort_error:
                logger.error(f" Last resort home screen setup failed: {last_resort_error}")

        if self.serial_thread:
            self.serial_thread.stop_monitoring()
            logger.info(" Serial monitoring stopped for game")
        
    def _reset_active_screen_state(self):
        """Reset Active_screen state without recreating objects to avoid resource conflicts (from CAGE)"""
        try:
            if not hasattr(self, 'ui_active') or not self.ui_active:
                logger.warning("Ô∏è  ui_active not available for state reset")
                return
            
            logger.info(" Resetting Active_screen state without object recreation...")
            
            # Reset game state variables specific to Fast Reaction
            global gameStarted, firstDetected, scored, serial_scoring_active
            global list_players_score, list_players_name
            
            gameStarted = False
            firstDetected = False
            scored = 0
            serial_scoring_active = False
            
            # Reset score tracking
            list_players_score = [0,0,0,0,0]
            list_players_name.clear()
            
            logger.debug(" Global game state variables reset")
            
            # Reset MediaPlayer state (reuse existing player) - Fast Reaction doesn't use MediaPlayer
            # Skip MediaPlayer reset for Fast Reaction
            
            # Reset MQTT thread state (reuse existing connection if available)
            if hasattr(self.ui_active, 'mqtt_thread') and self.ui_active.mqtt_thread:
                try:
                    # Check if MQTT is still connected
                    if (hasattr(self.ui_active.mqtt_thread, 'connected') and 
                        self.ui_active.mqtt_thread.connected and
                        hasattr(self.ui_active.mqtt_thread, 'client') and
                        self.ui_active.mqtt_thread.client):
                        logger.debug(" MQTT thread still connected, reusing existing connection")
                    else:
                        logger.debug(" MQTT thread disconnected, will reconnect on next game start")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error checking MQTT state: {e}")
            
            # Reset UI state if needed
            try:
                # Reset any timers (but don't recreate them)
                if hasattr(self.ui_active, 'timer') and self.ui_active.timer:
                    self.ui_active.timer.stop()
                
                if hasattr(self.ui_active, 'TimerGame') and self.ui_active.TimerGame:
                    self.ui_active.TimerGame.stop()
                
                # Reset circular timer state
                if hasattr(self.ui_active, 'reset_circular_timer'):
                    try:
                        self.ui_active.reset_circular_timer()
                        logger.debug(" Circular timer state reset")
                    except Exception as e:
                        logger.warning(f"Ô∏è  Error resetting circular timer state: {e}")
                
                logger.debug(" UI state reset completed")
                
            except Exception as e:
                logger.warning(f"Ô∏è  Error resetting UI state: {e}")
                
            logger.info(" Active_screen state reset completed without object recreation")
            
        except Exception as e:
            logger.error(f" Error in _reset_active_screen_state: {e}")

    def _safe_mqtt_subscribe(self):
        """Safely subscribe to MQTT data topics"""
        try:
            if hasattr(self, 'ui_active') and self.ui_active:
                if hasattr(self.ui_active, 'mqtt_thread') and self.ui_active.mqtt_thread:
                    self.ui_active.mqtt_thread.subscribe_to_data_topics()
                    logger.debug(" MQTT subscribed to data topics")
                else:
                    logger.warning("Ô∏è  MQTT thread not available for subscription")
        except Exception as e:
            logger.warning(f"Ô∏è  Error subscribing to MQTT: {e}")
    
    def _safe_mqtt_unsubscribe(self):
        """Safely unsubscribe from MQTT data topics"""
        try:
            if hasattr(self, 'ui_active') and self.ui_active:
                if hasattr(self.ui_active, 'mqtt_thread') and self.ui_active.mqtt_thread:
                    self.ui_active.mqtt_thread.unsubscribe_from_data_topics()
                    logger.debug(" MQTT unsubscribed from data topics")
                else:
                    logger.warning("Ô∏è  MQTT thread not available for unsubscription")
        except Exception as e:
            logger.warning(f"Ô∏è  Error unsubscribing from MQTT: {e}")
    
    def _cleanup_previous_screens(self):
        """Safely cleanup any previous screen resources"""
        logger.info(" Cleaning up previous screens...")
        
        # Clean up active screen
        if hasattr(self, 'ui_active') and self.ui_active:
            try:
                # Stop any running timers
                if hasattr(self.ui_active, 'timer') and self.ui_active.timer:
                    self.ui_active.timer.stop()
                if hasattr(self.ui_active, 'TimerGame') and self.ui_active.TimerGame:
                    self.ui_active.TimerGame.stop()
                # Don't close video here as it might be needed
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning up active screen: {e}")
        
        # Clean up final screen
        if hasattr(self, 'ui_final') and self.ui_final:
            try:
                if hasattr(self.ui_final, 'timer') and self.ui_final.timer:
                    self.ui_final.timer.stop()
                if hasattr(self.ui_final, 'timer2') and self.ui_final.timer2:
                    self.ui_final.timer2.stop()
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning up final screen: {e}")
        
        # Clean up home screen
        if hasattr(self, 'ui_home') and self.ui_home:
            try:
                if hasattr(self.ui_home, 'timer') and self.ui_home.timer:
                    self.ui_home.timer.stop()
                if hasattr(self.ui_home, 'timer2') and self.ui_home.timer2:
                    self.ui_home.timer2.stop()
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning up home screen: {e}")
        
        # Clean up team member screen
        if hasattr(self, 'ui_team_member') and self.ui_team_member:
            try:
                if hasattr(self.ui_team_member, 'timer') and self.ui_team_member.timer:
                    self.ui_team_member.timer.stop()
                if hasattr(self.ui_team_member, 'timer2') and self.ui_team_member.timer2:
                    self.ui_team_member.timer2.stop()
            except Exception as e:
                logger.warning(f"Ô∏è  Error cleaning up team member screen: {e}")
        
        logger.info(" Previous screens cleaned up")
    
    # def _active_screen_miss_signal_sound(self):
    #     # self.audio_thread.play_miss_sound()
    #     print("miss")
    # def _active_screen_ok_signal_sound(self):
    #     # self.audio_thread.play_ok_sound()
    #     print("Played ok sound")
    def _active_screen_crct_signal_sound(self):
        self.audio_thread.play_crct_sound()
    def _active_screen_mstk_signal_sound(self):
        self.audio_thread.play_mstk_sound()
    
    def _connect_active_screen_audio_signals(self):
        """Connect audio signals from Active_screen to MainApp audio handlers with proper disconnect-first pattern"""
        try:
            if not hasattr(self, 'ui_active') or not self.ui_active:
                logger.warning("Ô∏è  ui_active not available for audio signal connections")
                return False
            
            # Safely disconnect existing audio signal connections first
            # try:
            #     self.ui_active.miss_signal.disconnect(self._active_screen_miss_signal_sound)
            # except:
            #     pass  # Ignore if not connected
            
            # try:
            #     self.ui_active.ok_signal.disconnect(self._active_screen_ok_signal_sound)
            # except:
            #     pass  # Ignore if not connected
            
            # try:
            #     self.ui_active.crct_signal.disconnect(self._active_screen_crct_signal_sound)
            # except:
            #     pass  # Ignore if not connected
            
            # try:
            #     self.ui_active.mstk_signal.disconnect(self._active_screen_mstk_signal_sound)
            # except:
            #     pass  # Ignore if not connected
            
            # Connect audio signals
            # self.ui_active.miss_signal.connect(self._active_screen_miss_signal_sound)
            # self.ui_active.ok_signal.connect(self._active_screen_ok_signal_sound)
            self.ui_active.crct_signal.connect(self._active_screen_crct_signal_sound)
            self.ui_active.mstk_signal.connect(self._active_screen_mstk_signal_sound)
            
            logger.debug(" Active screen audio signals connected successfully")
            return True
            
        except Exception as e:
            logger.error(f" Error connecting active screen audio signals: {e}")
            return False

    def start_Active_screen(self):
        logger.info(" Starting Active Screen")
        self.audio_thread.play_active_game_sound()
        
        # Connect audio signals (regardless of serial availability)
        if not self._connect_active_screen_audio_signals():
            logger.warning("Ô∏è  Failed to connect active screen audio signals")
        # self.audio_thread.stop_continuous_sound()
        self.audio_thread.stop_inactive_game_sound()
        
        # Initialize active screen with error handling
        if hasattr(self, 'ui_active') and self.ui_active:
            try:
               
                
                # Reinitialize mqtt thread
                self.ui_active.setupUi(self.mainWindow)
# Safely close home screen

                self.ui_active.init_mqtt_thread()
               
                # Ensure circular timer widget is properly initialized for new game
                if hasattr(self.ui_active, 'centralwidget') and hasattr(self.ui_active, 'init_circular_timer_widget'):
                    try:
                        if self.ui_active.init_circular_timer_widget(self.ui_active.centralwidget):
                            logger.info(" Circular timer widget re-initialized for new game")
                            self.ui_active.circular_timer_widget.show()
                        else:
                            logger.warning("Ô∏è  Failed to re-initialize circular timer widget")
                    except Exception as e:
                        logger.error(f" Error re-initializing circular timer widget: {e}")
                
                # Connect deactivate signal to trigger score submission
                if (hasattr(self.ui_active, 'mqtt_thread') and self.ui_active.mqtt_thread and 
                    hasattr(self.ui_active.mqtt_thread, 'deactivate_signal')):
                    try:
                        self.ui_active.mqtt_thread.deactivate_signal.connect(
                            self.game_manager.trigger_score_submission
                        )
                        logger.debug(" Deactivate signal connected to GameManager")
                    except Exception as e:
                        logger.warning(f"Ô∏è  Error connecting deactivate signal: {e}")
                else:
                    logger.warning("Ô∏è  MQTT thread or deactivate signal not properly initialized")
                # Ensure serial thread is properly set up
                if hasattr(self, 'serial_thread') and self.serial_thread:
                    try:
                        # Update the serial thread reference in ui_active
                        self.ui_active.serial_thread = self.serial_thread
                        
                        # Ensure serial thread is ready (but don't start monitoring yet - that happens in start_game)
                        if hasattr(self.serial_thread, 'connect') and not self.serial_thread.connected:
                            self.serial_thread.connect()
                            logger.debug(" Serial connection established")
                        else:
                            logger.debug(" Serial thread ready")
                        
                        # Ensure signals are connected (disconnect first to avoid duplicates, then reconnect)
                        try:
                            # Safely disconnect existing serial connections
                            self.serial_thread.data_received.disconnect(self.ui_active.on_serial_data_received)
                        except:
                            pass  # Ignore if not connected
                        
                        try:
                            self.serial_thread.connection_status_changed.disconnect(self.ui_active.on_serial_connection_status_changed)
                        except:
                            pass  # Ignore if not connected
                        
                        try:
                            self.serial_thread.error_occurred.disconnect(self.ui_active.on_serial_error)
                        except:
                            pass  # Ignore if not connected
                        
                        # Reconnect serial signals
                        self.serial_thread.data_received.connect(self.ui_active.on_serial_data_received)
                        self.serial_thread.connection_status_changed.connect(self.ui_active.on_serial_connection_status_changed)
                        self.serial_thread.error_occurred.connect(self.ui_active.on_serial_error)
                        logger.debug(" Serial and audio signals ensured connected")
                        
                        logger.debug(" Serial thread properly configured for Active_screen")
                    except Exception as e:
                        logger.warning(f"Ô∏è  Error configuring serial thread: {e}")
                else:
                    logger.info("‚ÑπÔ∏è  Serial thread not available (disabled in config or failed to initialize)")
                
                
                # Setup and show the active screen
                # self.mainWindow.show()
                logger.debug(" Active screen started successfully")
            except Exception as e:
                logger.error(f" Error setting up active screen: {e}")
                return
        else:
            logger.error(" ui_active not properly initialized")
            return

        if hasattr(self, 'ui_home') and self.ui_home:
            try:
                self.ui_home.close()
            except Exception as e:
                logger.warning(f"Ô∏è  Error closing home screen: {e}")
        
        quit_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence('q'), self.mainWindow)
        quit_shortcut.activated.connect(self.close_application)

    def start_final_screen(self):
        """Start Final Screen with comprehensive error handling (improved from game2)"""
        logger.info(" Starting Final Screen")
        try:
            # Close any current screens safely
            self._close_current_screen()
            self.audio_thread.stop_continuous_sound()
            self.audio_thread.stop_active_game_sound()
            self.audio_thread.play_inactive_game_sound()
            # Setup and show final screen
            self.ui_final.setupUi(self.mainWindow)
            self.mainWindow.show()
            logger.debug(" Final screen started successfully")
            
            # Read timer value from file with fallback
            try:
                with open("file.txt", "r") as file:
                    lines = file.readlines()
                    if lines:
                        final_screen_timer_idle = int(lines[-1].strip())
                    else:
                        final_screen_timer_idle = game_config.final_screen_timer
            except FileNotFoundError:
                logger.info("file.txt not found. Using default timer value.")
                final_screen_timer_idle = game_config.final_screen_timer
            except (ValueError, IndexError) as e:
                logger.warning(f"Ô∏è  Error reading timer value: {e}. Using default.")
                final_screen_timer_idle = game_config.final_screen_timer
            
            # Override with default for consistency
            final_screen_timer_idle = 15000
            
            # Set up automatic transition back to home screen after final_screen_timer_idle (improved from game2)
            logger.info(f"‚è∞ Setting final screen auto-transition timer: {final_screen_timer_idle}ms")
            QtCore.QTimer.singleShot(final_screen_timer_idle, lambda: (
                self.ui_final.close() if hasattr(self, 'ui_final') and self.ui_final is not None and self.ui_final.isVisible() else None,
                self.start_Home_screen() if hasattr(self, 'ui_final') and self.ui_final is not None and not self.ui_final.isVisible() else None
            ))
            
        except Exception as e:
            logger.error(f" Error starting final screen: {e}")

        quit_shortcut = QtWidgets.QShortcut(QtGui.QKeySequence('q'), self.mainWindow)
        quit_shortcut.activated.connect(self.close_application)

    def _close_current_screen(self):
        """Safely close any currently active screen (improved from game2)"""
        try:
            # Clear central widget content
            central_widget = self.mainWindow.centralWidget()
            if central_widget:
                # Get all child widgets
                for child in central_widget.findChildren(QtWidgets.QWidget):
                    try:
                        child.hide()
                        child.deleteLater()
                    except RuntimeError:
                        # Widget already deleted
                        pass
                
                # Clear the central widget
                central_widget.deleteLater()
                self.mainWindow.setCentralWidget(None)
                
            logger.debug(" Current screen closed successfully")
        except Exception as e:
            logger.warning(f"Ô∏è  Error closing current screen: {e}")

    def close_application(self):
        """Comprehensive application cleanup and shutdown"""
        logger.info(" Closing application with comprehensive cleanup...")
        
        try:
            # Stop GameManager thread first
            if hasattr(self, 'game_manager') and self.game_manager:
                try:
                    self.game_manager.stop_manager()
                    logger.debug(" GameManager stopped")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error stopping GameManager: {e}")
            
            # Stop Serial thread
            if hasattr(self, 'serial_thread') and self.serial_thread:
                try:
                    self.serial_thread.stop()
                    self.serial_thread = None
                    logger.debug(" Serial thread stopped")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error stopping Serial thread: {e}")
            
            # Clean up all UI screens
            self._cleanup_all_screens()
            
            # Close main window
            if hasattr(self, 'mainWindow') and self.mainWindow:
                try:
                    self.mainWindow.close()
                    logger.debug(" Main window closed")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error closing main window: {e}")
            
        except Exception as e:
            logger.error(f" Error during application cleanup: {e}")
        
        # Quit the application
        QtWidgets.QApplication.quit()
        logger.info(" Application shutdown complete")
    
    def closeEvent(self, event):
        """Handle application close event with comprehensive cleanup"""
        logger.info(" MainApp closeEvent triggered...")
        
        try:
            # Perform the same cleanup as close_application
            if hasattr(self, 'game_manager') and self.game_manager:
                self.game_manager.stop_manager()
            
            # Stop Serial thread
            if hasattr(self, 'serial_thread') and self.serial_thread:
                try:
                    self.serial_thread.stop()
                    self.serial_thread = None
                    logger.debug(" Serial thread stopped in closeEvent")
                except Exception as e:
                    logger.warning(f"Ô∏è  Error stopping Serial thread in closeEvent: {e}")
            
            self._cleanup_all_screens()
            
        except Exception as e:
            logger.error(f" Error in MainApp closeEvent: {e}")
        
        event.accept()
        logger.info(" MainApp closeEvent completed")
        super().closeEvent(event)
    
    def _cleanup_all_screens(self):
        """Cleanup all screen instances and their resources"""
        logger.info(" Cleaning up all screens...")
        
        # Clean up active screen
        if hasattr(self, 'ui_active') and self.ui_active:
            try:
                self.ui_active.close()
                logger.debug(" Active screen closed")
            except Exception as e:
                logger.warning(f"Ô∏è  Error closing active screen: {e}")
        
        # Clean up final screen  
        if hasattr(self, 'ui_final') and self.ui_final:
            try:
                self.ui_final.close()
                logger.debug(" Final screen closed")
            except Exception as e:
                logger.warning(f"Ô∏è  Error closing final screen: {e}")
        
        # Clean up home screen
        if hasattr(self, 'ui_home') and self.ui_home:
            try:
                self.ui_home.close()
                logger.debug(" Home screen closed")
            except Exception as e:
                logger.warning(f"Ô∏è  Error closing home screen: {e}")
        
        # Clean up team member screen
        if hasattr(self, 'ui_team_member') and self.ui_team_member:
            try:
                self.ui_team_member.close()
                logger.debug(" TeamMember screen closed")
            except Exception as e:
                logger.warning(f"Ô∏è  Error closing team member screen: {e}")
        
        logger.info(" All screens cleaned up")
    
    def _force_stop_all_timers(self):
        """Force stop all timers across all screens for safe shutdown"""
        logger.info(" Force stopping all application timers")
        
        # Stop timers in all screen instances
        screen_attrs = ['ui_home', 'ui_active', 'ui_final', 'ui_team_member']
        for screen_attr in screen_attrs:
            if hasattr(self, screen_attr):
                screen = getattr(self, screen_attr)
                if screen:
                    # Check for common timer names and stop them
                    timer_names = ['timer', 'timer2', 'timer3', 'TimerGame', 'traverse_Timer']
                    for timer_name in timer_names:
                        if hasattr(screen, timer_name):
                            timer_obj = getattr(screen, timer_name)
                            if timer_obj:
                                try:
                                    if hasattr(timer_obj, 'stop'):
                                        timer_obj.stop()
                                        logger.debug(f" {screen_attr}.{timer_name} stopped")
                                except (RuntimeError, AttributeError):
                                    logger.debug(f"Ô∏è  {screen_attr}.{timer_name} already deleted or invalid")
                                except Exception as e:
                                    logger.warning(f"Ô∏è  Error stopping {screen_attr}.{timer_name}: {e}")
        
        logger.info(" All application timers forcibly stopped")


if __name__ == "__main__":
    # Initialize logging
    from utils.logger import setup_root_logger
    setup_root_logger("INFO")
    
    logger.info("" + "=" * 60)
    logger.info(" STARTING CAGE GAME WITH COMPLETE UI AND NEW API")
    logger.info("" + "=" * 60)
    
    app = QtWidgets.QApplication(sys.argv)
    
    # Initialize leaderboard
    try:
        api = GameAPI()
        if api.authenticate():
            logger.info(" API authentication successful")
            # TODO: Uncomment when leaderboard is needed
            leaderboard = api.get_leaderboard()
            list_top5_FastReaction.extend(leaderboard)
            logger.info(f" Initial leaderboard loaded: {len(leaderboard)} entries")
        else:
            logger.warning("Ô∏è  Failed to authenticate for initial leaderboard")
    except Exception as e:
        logger.error(f" Error loading initial leaderboard: {e}")
    
    # Start main application
    try:
        main_app = MainApp()
        logger.info(" Application started successfully!")
        
        # Log serial configuration status
        serial_config = config.settings.serial
        if serial_config.enabled:
            logger.info(f" Serial communication enabled: {serial_config.port}")
        else:
            logger.info(" Serial communication disabled (MQTT only mode)")
            logger.info(" To enable serial: Set FAST_REACTION_SERIAL_ENABLED=true and FAST_REACTION_SERIAL_PORT=/dev/ttyUSB0")
        
        sys.exit(app.exec_())
    except Exception as e:
        logger.error(f" Application failed to start: {e}")
        import traceback
        logger.error(traceback.format_exc())
        sys.exit(1)
